{"Map":{"aliases":["Map"],"isClass":true,"methods":[{"name":"get","computed":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"},{"name":"optDefaultValue","type":{"type":"AllLiteral","optional":true},"typeAsHTML":"*="}],"description":"Returns the value for the given key.\n\nUnlike native ES6 maps, this also accepts a default value which is returned\nif the map does not contain the value.","returns":{"type":{"type":"AllLiteral"},"typeAsHTML":"*"},"see":[],"async":false},{"name":"has","computed":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Returns true if the key is in the map.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"},"see":[],"async":false},{"name":"set","computed":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"},{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Adds the value and key to the map.","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"the map object itself"},"see":[],"async":false},{"name":"delete","computed":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Remove value with given key.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"},"see":[],"async":false},{"name":"entries","computed":false,"params":[],"description":"Returns an array of (key, value) tuples.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"},"see":[],"async":false},{"name":"keys","computed":false,"params":[],"description":"Returns an iterator over keys.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"},"see":[],"async":false},{"name":"values","computed":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"},"see":[],"async":false},{"name":"clear","computed":false,"params":[],"description":"Empties the map.","see":[],"async":false},{"name":"forEach","computed":false,"params":[{"name":"callback","type":{"type":"FunctionType","params":[{"type":"AllLiteral"},{"type":"AllLiteral"}]},"typeAsHTML":"function(*, *)","description":"A function which gets the key as first\nargument and value as second argument."},{"name":"opt_this","type":{"type":"AllLiteral","optional":true},"typeAsHTML":"*=","description":"Object/value to set this to inside the callback"}],"description":"Executes the provided callback for each item in the map.","see":[],"async":false},{"name":"Symbol.iterator","computed":true,"params":[],"description":"Returns an iterator for the map object.","returns":{"type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator"},"see":[],"async":false}],"properties":[{"name":"size","computed":false,"params":[],"description":"Returns the number of element in the map.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"readonly":false}],"staticMethods":[],"staticProperties":[],"constructor":{"name":"Map","computed":false,"params":[{"name":"opt_data","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"An object, array or iterator to\npopulate the map with. If 'data' is an array or iterable, each element is\nexpected to be a 2-tuple. The first element will be the key and second the\nvalue.\nIf it is an object, the property names will be the keys and the value the\nvalues."}],"description":"","see":[],"async":false},"categories":[]},"Set":{"aliases":["Set"],"isClass":true,"methods":[{"name":"has","computed":false,"params":[{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Returns true if the key is in the map.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"},"see":[],"async":false},{"name":"add","computed":false,"params":[{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Adds the value and key to the map.","see":[],"async":false},{"name":"delete","computed":false,"params":[{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Remove value with given key.","see":[],"async":false},{"name":"values","computed":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"},"see":[],"async":false},{"name":"keys","computed":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"},"see":[],"async":false},{"name":"entries","computed":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"},"see":[],"async":false},{"name":"clear","computed":false,"params":[],"description":"Empties the set.","see":[],"async":false},{"name":"forEach","computed":false,"params":[{"name":"callback","type":{"type":"FunctionType","params":[{"type":"AllLiteral"}]},"typeAsHTML":"function(*)","description":"A function which gets the key as first\nargument and value as second argument."},{"name":"opt_this","type":{"type":"AllLiteral","optional":true},"typeAsHTML":"*=","description":"Object/value to set this to inside the callback"}],"description":"Executes the provided callback for each item in the set.","see":[],"async":false},{"name":"difference","computed":false,"params":[{"name":"others","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Set"},{"type":"NameExpression","name":"Array"}],"repeatable":true},"typeAsHTML":"...(Set|Array)"}],"description":"Returns a new set with the values of this set, not found in the other\nsets.","see":[],"async":false},{"name":"intersection","computed":false,"params":[{"name":"others","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Set"},{"type":"NameExpression","name":"Array"}],"repeatable":true},"typeAsHTML":"...(Set|Array)"}],"description":"Returns a new set containing only elements found in this and every\nother set/array.","see":[],"async":false},{"name":"pop","computed":false,"params":[],"description":"Removes and returns an element from the set.","returns":{"type":{"type":"UnknownLiteral"},"typeAsHTML":"?"},"see":[],"async":false},{"name":"Symbol.iterator","computed":true,"params":[],"description":"Returns an iterator for the set object.","returns":{"type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator"},"see":[],"async":false}],"properties":[{"name":"size","computed":false,"params":[],"description":"Returns the number of element in the set.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"readonly":false}],"staticMethods":[],"staticProperties":[],"constructor":{"name":"Set","computed":false,"params":[{"name":"opt_data","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":" An object, array or iterator to populate the set\nwith."}],"description":"","see":[],"async":false},"categories":[]},"forEach":{"aliases":["forEach"],"name":"forEach","params":[{"name":"seq","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable"},{"name":"callback","type":{"type":"FunctionType","params":[{"repeatable":true}],"this":{"type":"NameExpression","name":"T"}},"typeAsHTML":"function(this:T, ...[])"},{"name":"optThisObj","type":{"type":"NameExpression","name":"T","optional":true},"typeAsHTML":"T="}],"description":"Helper to iterate over sequence types (arrays, array-like objects,\nobjects, etc)","see":[],"async":false,"categories":[]},"toArray":{"aliases":["toArray"],"categories":[]},"betweennessCentrality":{"name":"betweennessCentrality","aliases":["betweennessCentrality","algorithms.betweennessCentrality","algorithms.centrality.betweennessCentrality","algorithms.centrality.betweenness.betweennessCentrality","algorithms.betweenness.betweennessCentrality","centrality.betweennessCentrality","centrality.betweenness.betweennessCentrality","betweenness.betweennessCentrality"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","description":"A JSNetworkX graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"k"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"normalized"},"value":{"type":"NameExpression","name":"bool","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"endpoints"},"value":{"type":"NameExpression","name":"bool","nullable":true}}],"optional":true},"typeAsHTML":"{k: ?number, normalized: ?bool, weight: ?string, endpoints: ?bool}=","description":"\n- `k` (int)\n\n  If `k` is defined use `k` node samples to estimate betweenness.\n  The value of `k <= n` where `n` is the number of nodes in the graph.\n  Higher values give better approximation.\n- `normalized` (bool)\n\n  If `true`, the betweenness values are normalized by `2/((n-1)(n-2))`\n  for graphs and `1/((n-1)(n-2))` for directed graphs where `n` is the\n  number of nodes in G.\n- `weight` (default=null)\n\n  If null, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n\n- `endpoints` (default=false)\n\n  If true include the endpoints in the shortest path counts.","defaultValue":"{}"}],"description":"Compute the shortest-path betweenness centrality for nodes.\n\nBetweenness centrality of a node `$v$` is the sum of the\nfraction of all-pairs shortest paths that pass through `$v$`:\n\n```math\nc_B(v) = \\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n```\n\nwhere `$V$` is the set of nodes, `$\\sigma(s, t)$` is the number of\nshortest `$(s, t)$`-paths,  and `$\\sigma(s, t|v)$` is the number of those\npaths  passing through some  node `$v$` other than `$s, t$`.\nIf `$s = t$`, `$\\sigma(s, t) = 1$`, and if `$v \\in {s, t}$`,\n`$\\sigma(s, t|v) = 0$` ([2][]).\n\n### Notes\n\nThe algorithm is from Ulrik Brandes ([1][]):\n\nSee ([2][]) for details on algorithms for variations and related metrics.\n\nFor approximate betweenness calculations set `k=#samples` to use\n`k` nodes (\"pivots\") to estimate the betweenness values. For an estimate\nof the number of pivots needed see ([3][]).\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\n### References\n\n[1] [A Faster Algorithm for Betweenness Centrality.\n   Ulrik Brandes,\n   Journal of Mathematical Sociology 25(2):163-177, 2001.][1]\n[1]: http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf\n\n[2] [Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.][2]\n[2]: http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n\n[3] [Ulrik Brandes and Christian Pich:\n   Centrality Estimation in Large Networks.\n   International Journal of Bifurcation and Chaos 17(7):2303-2318, 2007.][3]\n[3]: http://www.inf.uni-konstanz.de/algo/publications/bp-celn-06.pdf","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"object with node keys with betweenness centrality as the value."},"see":["edgeBetweennessCentrality","loadCentrality"],"async":false,"asyncName":"genBetweennessCentrality","categories":["algorithms","centrality","betweenness"]},"genBetweennessCentrality":{"name":"genBetweennessCentrality","aliases":["genBetweennessCentrality","algorithms.genBetweennessCentrality","algorithms.centrality.genBetweennessCentrality","algorithms.centrality.betweenness.genBetweennessCentrality","algorithms.betweenness.genBetweennessCentrality","centrality.genBetweennessCentrality","centrality.betweenness.genBetweennessCentrality","betweenness.genBetweennessCentrality"],"syncName":"betweennessCentrality","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","description":"A JSNetworkX graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"k"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"normalized"},"value":{"type":"NameExpression","name":"bool","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"endpoints"},"value":{"type":"NameExpression","name":"bool","nullable":true}}],"optional":true},"typeAsHTML":"{k: ?number, normalized: ?bool, weight: ?string, endpoints: ?bool}=","description":"\n- `k` (int)\n\n  If `k` is defined use `k` node samples to estimate betweenness.\n  The value of `k <= n` where `n` is the number of nodes in the graph.\n  Higher values give better approximation.\n- `normalized` (bool)\n\n  If `true`, the betweenness values are normalized by `2/((n-1)(n-2))`\n  for graphs and `1/((n-1)(n-2))` for directed graphs where `n` is the\n  number of nodes in G.\n- `weight` (default=null)\n\n  If null, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n\n- `endpoints` (default=false)\n\n  If true include the endpoints in the shortest path counts.","defaultValue":"{}"}],"categories":["algorithms","centrality","betweenness"]},"edgeBetweennessCentrality":{"name":"edgeBetweennessCentrality","aliases":["edgeBetweennessCentrality","algorithms.edgeBetweennessCentrality","algorithms.centrality.edgeBetweennessCentrality","algorithms.centrality.betweenness.edgeBetweennessCentrality","algorithms.betweenness.edgeBetweennessCentrality","centrality.edgeBetweennessCentrality","centrality.betweenness.edgeBetweennessCentrality","betweenness.edgeBetweennessCentrality"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","description":"A NetworkX graph"},{"name":"optArgDict","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"normalized"},"value":{"type":"NameExpression","name":"bool","optional":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","optional":true}}],"optional":true},"typeAsHTML":"{normalized: bool=, weight: string=}=","description":"\n- `normalized` (default=false)\n\n  If true the betweenness values are normalized by `2/(n(n-1))`\n  for graphs, and `1/(n(n-1))` for directed graphs where `n`\n  is the number of nodes in G.\n\n- `weight` (default=null)\n\n  If null, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.","defaultValue":"{}"}],"description":"Compute betweenness centrality for edges.\n\nBetweenness centrality of an edge `$e$` is the sum of the\nfraction of all-pairs shortest paths that pass through `$e$`:\n\n```math\nc_B(v) = \\sum_{s,t \\in V} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}\n```\n\nwhere `$V$` is the set of nodes, `$\\sigma(s, t)$` is the number of\nshortest `$(s, t)$`-paths, and `$\\sigma(s, t|e)$` is the number of\nthose paths passing through edge `$e$` ([2][]).\n\n### Notes\n\nThe algorithm is from Ulrik Brandes ([1][]).\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\n### References\n\n[1] [A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\n   Journal of Mathematical Sociology 25(2):163-177, 2001.][1]\n[1]: http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf\n[2] [Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.][2]\n[2]: http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"object with edge keys with betweenness centrality as the value."},"see":["betweennessCentrality","edgeLoad"],"async":false,"asyncName":"genEdgeBetweennessCentrality","categories":["algorithms","centrality","betweenness"]},"genEdgeBetweennessCentrality":{"name":"genEdgeBetweennessCentrality","aliases":["genEdgeBetweennessCentrality","algorithms.genEdgeBetweennessCentrality","algorithms.centrality.genEdgeBetweennessCentrality","algorithms.centrality.betweenness.genEdgeBetweennessCentrality","algorithms.betweenness.genEdgeBetweennessCentrality","centrality.genEdgeBetweennessCentrality","centrality.betweenness.genEdgeBetweennessCentrality","betweenness.genEdgeBetweennessCentrality"],"syncName":"edgeBetweennessCentrality","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","description":"A NetworkX graph"},{"name":"optArgDict","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"normalized"},"value":{"type":"NameExpression","name":"bool","optional":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","optional":true}}],"optional":true},"typeAsHTML":"{normalized: bool=, weight: string=}=","description":"\n- `normalized` (default=false)\n\n  If true the betweenness values are normalized by `2/(n(n-1))`\n  for graphs, and `1/(n(n-1))` for directed graphs where `n`\n  is the number of nodes in G.\n\n- `weight` (default=null)\n\n  If null, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.","defaultValue":"{}"}],"categories":["algorithms","centrality","betweenness"]},"eigenvectorCentrality":{"name":"eigenvectorCentrality","aliases":["eigenvectorCentrality","algorithms.eigenvectorCentrality","algorithms.centrality.eigenvectorCentrality","algorithms.centrality.eigenvector.eigenvectorCentrality","algorithms.eigenvector.eigenvectorCentrality","centrality.eigenvectorCentrality","centrality.eigenvector.eigenvectorCentrality","eigenvector.eigenvectorCentrality"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"maxIter"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"tolerance"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"nstart"},"value":{"type":"NameExpression","name":"Map","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{maxIter: ?number, tolerance: ?number, nstart: ?Map, weight: ?string}","description":"\n- maxIter: Maximum number of iterations in power method.\n- tolerance: Error tolerance used to check convergence in power method\n  iteration.\n- nstart: Starting value of eigenvector iteration for each node.\n- weight: If not defined, all edge weights are considered equal. Otherwise\n  holds the name of the edge attribute used as weight.","defaultValue":"{}"}],"description":"Compute the eigenvector centrality for `G`.\n\nEigenvector centrality computes the centrality for a node based on the\ncentrality of its neighbors. The eigenvector centrality for node `i` is\n\n```math\nAx = \\lambda x\n```\n\nwhere `$A$` is the adjacency matrix of the graph `G` with eigenvalue\n`$\\lambda$`. By virtue of the Perron-Frobinus theorem, there is a unique and\npositive solution if `$\\lambda$` is the largest eigenvalue associated with\nthe eigenvector of the adjacency matrix `$A$`. ([2])\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(4);\njsnx.eigenvectorCentrality(G);\n// Map {0: 0.37, 1: 0.6, 2: 0.6, 3: 0.37}\n```\n\n### Notes\n\nThe measure was introduced by ([1][]).\n\nThe eigenvector calculation is done by the power iteration method and has\nno guarantee of convergence. The iteration will stop after `maxIter`\niterations or an error tolerance of `numberOfNodes(G) * tol` has been\nreached.\n\nFor directed graphs this is \"left\" eigenvector centrality which corresponds\nto the in-edges in the graph. For out-edges eigenvector centrality\nfirst reverse the graph with `G.reverse()`.\n\n### References\n\n[1] [Phillip Bonacich:\n    Power and Centrality: A Family of Measures.\n    American Journal of Sociology 92(5):1170–1182, 1986](1)\n[1]: http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf\n[2] Mark E. J. Newman:\n    Networks: An Introduction.\n    Oxford University Press, USA, 2010, pp. 169.","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"Map of nodes with eigenvector centrality as the value"},"see":["pagerank","hits"],"async":false,"asyncName":"genEigenvectorCentrality","categories":["algorithms","centrality","eigenvector"]},"genEigenvectorCentrality":{"name":"genEigenvectorCentrality","aliases":["genEigenvectorCentrality","algorithms.genEigenvectorCentrality","algorithms.centrality.genEigenvectorCentrality","algorithms.centrality.eigenvector.genEigenvectorCentrality","algorithms.eigenvector.genEigenvectorCentrality","centrality.genEigenvectorCentrality","centrality.eigenvector.genEigenvectorCentrality","eigenvector.genEigenvectorCentrality"],"syncName":"eigenvectorCentrality","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"maxIter"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"tolerance"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"nstart"},"value":{"type":"NameExpression","name":"Map","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{maxIter: ?number, tolerance: ?number, nstart: ?Map, weight: ?string}","description":"\n- maxIter: Maximum number of iterations in power method.\n- tolerance: Error tolerance used to check convergence in power method\n  iteration.\n- nstart: Starting value of eigenvector iteration for each node.\n- weight: If not defined, all edge weights are considered equal. Otherwise\n  holds the name of the edge attribute used as weight.","defaultValue":"{}"}],"categories":["algorithms","centrality","eigenvector"]},"findCliques":{"name":"findCliques","aliases":["findCliques","algorithms.findCliques","algorithms.clique.findCliques","clique.findCliques"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Search for all maximal cliques in a graph.\n\nMaximal cliques are the largest complete subgraph containing\na given node.  The largest maximal clique is sometimes called\nthe maximum clique.\n\n\n### Notes\n\nBased on the algorithm published by Bron & Kerbosch (1973) ([1][])\nas adapted by Tomita, Tanaka and Takahashi (2006) ([2][])\nand discussed in Cazals and Karande (2008) ([3][]).\n\nThis algorithm ignores self-loops and parallel edges as\nclique is not conventionally defined with such edges.\n\nThere are often many cliques in graphs.  This algorithm can\nrun out of memory for large graphs.\n\n### References\n\n[1] [Bron, C. and Kerbosch, J. 1973.\n   Algorithm 457: finding all cliques of an undirected graph.\n   Commun. ACM 16, 9 (Sep. 1973), 575-577.][1]\n[1]: http://portal.acm.org/citation.cfm?doid=362342.362367\n\n[2] [Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n   The worst-case time complexity for generating all maximal\n   cliques and computational experiments,\n   Theoretical Computer Science, Volume 363, Issue 1,\n   Computing and Combinatorics,\n   10th Annual International Conference on\n   Computing and Combinatorics (COCOON 2004), 25 October 2006,\n   Pages 28-42][2]\n[2]: http://dx.doi.org/10.1016/j.tcs.2006.06.015\n\n[3] [F. Cazals, C. Karande,\n   A note on the problem of reporting maximal cliques,\n   Theoretical Computer Science,\n   Volume 407, Issues 1-3, 6 November 2008, Pages 564-568][3]\n[3]: http://dx.doi.org/10.1016/j.tcs.2008.05.010","returns":{"name":"","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Iterator"},"applications":[{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"Node"}]}]},"typeAsHTML":"Iterator.&lt;Array.&lt;Node>>","description":"Iterator over member lists for each maximal\nclique"},"see":"findCliquesRecursive","async":false,"asyncName":"genFindCliques","categories":["algorithms","clique"]},"genFindCliques":{"name":"genFindCliques","aliases":["genFindCliques","algorithms.genFindCliques","algorithms.clique.genFindCliques","clique.genFindCliques"],"syncName":"findCliques","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","clique"]},"findCliquesRecursive":{"name":"findCliquesRecursive","aliases":["findCliquesRecursive","algorithms.findCliquesRecursive","algorithms.clique.findCliquesRecursive","clique.findCliquesRecursive"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Recursive search for all maximal cliques in a graph.\n\nMaximal cliques are the largest complete subgraph containing\na given point.  The largest maximal clique is sometimes called\nthe maximum clique.\n\n### Notes\n\nBased on the algorithm published by Bron & Kerbosch (1973) ([1][])\nas adapted by Tomita, Tanaka and Takahashi (2006) ([2][])\nand discussed in Cazals and Karande (2008) ([3][]).\n\nThis algorithm ignores self-loops and parallel edges as\nclique is not conventionally defined with such edges.\n\n\n### References\n\n[1] [Bron, C. and Kerbosch, J. 1973.\n   Algorithm 457: finding all cliques of an undirected graph.\n   Commun. ACM 16, 9 (Sep. 1973), 575-577.][1]\n[1]: http://portal.acm.org/citation.cfm?doid=362342.362367\n\n[2] [Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n   The worst-case time complexity for generating all maximal\n   cliques and computational experiments,\n   Theoretical Computer Science, Volume 363, Issue 1,\n   Computing and Combinatorics,\n   10th Annual International Conference on\n   Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28-42][2]\n[2]: http://dx.doi.org/10.1016/j.tcs.2006.06.015\n\n[3] [F. Cazals, C. Karande,\n   A note on the problem of reporting maximal cliques,\n   Theoretical Computer Science,\n   Volume 407, Issues 1-3, 6 November 2008, Pages 564-568][3]\n[3]: http://dx.doi.org/10.1016/j.tcs.2008.05.010","returns":{"name":"","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Iterator"},"applications":[{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"Node"}]}],"nullable":false},"typeAsHTML":"!Iterator.&lt;Array.&lt;Node>>","description":"List of members in each maximal clique"},"see":"find_cliques","async":false,"asyncName":"genFindCliquesRecursive","categories":["algorithms","clique"]},"genFindCliquesRecursive":{"name":"genFindCliquesRecursive","aliases":["genFindCliquesRecursive","algorithms.genFindCliquesRecursive","algorithms.clique.genFindCliquesRecursive","clique.genFindCliquesRecursive"],"syncName":"findCliquesRecursive","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","clique"]},"graphCliqueNumber":{"name":"graphCliqueNumber","aliases":["graphCliqueNumber","algorithms.graphCliqueNumber","algorithms.clique.graphCliqueNumber","clique.graphCliqueNumber"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable="}],"description":"Return the clique number (size of the largest clique) for G.\n\nAn optional list of cliques can be input if already computed.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"asyncName":"genGraphCliqueNumber","categories":["algorithms","clique"]},"genGraphCliqueNumber":{"name":"genGraphCliqueNumber","aliases":["genGraphCliqueNumber","algorithms.genGraphCliqueNumber","algorithms.clique.genGraphCliqueNumber","clique.genGraphCliqueNumber"],"syncName":"graphCliqueNumber","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable="}],"categories":["algorithms","clique"]},"graphNumberOfCliques":{"name":"graphNumberOfCliques","aliases":["graphNumberOfCliques","algorithms.graphNumberOfCliques","algorithms.clique.graphNumberOfCliques","clique.graphNumberOfCliques"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable="}],"description":"Returns the number of maximal cliques in G.\n\nAn optional list of cliques can be input if already computed.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"asyncName":"genGraphNumberOfCliques","categories":["algorithms","clique"]},"genGraphNumberOfCliques":{"name":"genGraphNumberOfCliques","aliases":["genGraphNumberOfCliques","algorithms.genGraphNumberOfCliques","algorithms.clique.genGraphNumberOfCliques","clique.genGraphNumberOfCliques"],"syncName":"graphNumberOfCliques","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable="}],"categories":["algorithms","clique"]},"numberOfCliques":{"name":"numberOfCliques","aliases":["numberOfCliques","algorithms.numberOfCliques","algorithms.clique.numberOfCliques","clique.numberOfCliques"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"List of nodes"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"List of cliques"}],"description":"Returns the number of maximal cliques for each node.\n\nReturns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed.","returns":{"type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"number"}],"nullable":false},"typeAsHTML":"!(Map|number)"},"see":[],"async":false,"asyncName":"genNumberOfCliques","categories":["algorithms","clique"]},"genNumberOfCliques":{"name":"genNumberOfCliques","aliases":["genNumberOfCliques","algorithms.genNumberOfCliques","algorithms.clique.genNumberOfCliques","clique.genNumberOfCliques"],"syncName":"numberOfCliques","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"List of nodes"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"List of cliques"}],"categories":["algorithms","clique"]},"triangles":{"name":"triangles","aliases":["triangles","algorithms.triangles","algorithms.cluster.triangles","cluster.triangles"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A JSnetworkX graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default: all nodes)\n    Compute triangles for nodes in this container."}],"description":"Compute the number of triangles.\n\nFinds the number of triangles that include a node as one vertex.\n\n### Examples\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.triangles(G, 0);\n// 6\njsnx.triangles(G);\nMap {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\nArray.from(jsnx.triangles(G, [0,1]).values());\n// [6, 6]\n```\n\n### Notes\n\nWhen computing triangles for the entire graph each triangle is counted\nthree times, once at each node.  Self loops are ignored.","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"number"}],"nullable":false},"typeAsHTML":"!(Map|number)","description":"Number of triangles keyed by node label."},"see":[],"async":false,"asyncName":"genTriangles","categories":["algorithms","cluster"]},"genTriangles":{"name":"genTriangles","aliases":["genTriangles","algorithms.genTriangles","algorithms.cluster.genTriangles","cluster.genTriangles"],"syncName":"triangles","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A JSnetworkX graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default: all nodes)\n    Compute triangles for nodes in this container."}],"categories":["algorithms","cluster"]},"averageClustering":{"name":"averageClustering","aliases":["averageClustering","algorithms.averageClustering","algorithms.cluster.averageClustering","cluster.averageClustering"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","nullable":true},"typeAsHTML":"?Iterable","description":"(default: all nodes)\n  Compute average clustering for nodes in this container."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","description":"(default: null)\n  The edge attribute that holds the numerical value used as a weight.\n  If `null`, then each edge has weight `1`."},{"name":"optCountZeros","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"\nIf `false` include only the nodes with nonzero clustering in the average.","defaultValue":"true"}],"description":"Compute the average clustering coefficient for the graph G.\n\nThe clustering coefficient for the graph is the average,\n\n```math\nC = \\frac{1}{n}\\sum_{v \\in G} c_v\n```\n\nwhere `$n$` is the number of nodes in `$G$`.\n\n### Example\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.averageClustering(G);\n// 1\n```\n\n### Notes\n\nSelf loops are ignored.\n\n\n### References\n\n[1] [Generalizations of the clustering coefficient to weighted\n    complex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,\n    K. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).][1]\n[1]: http://jponnela.com/web_documents/a9.pdf\n[2] [Marcus Kaiser,  Mean clustering coefficients: the role of isolated\n    nodes and leafs on clustering measures for small-world networks.][2]\n[2]:http://arxiv.org/abs/0802.2512","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"asyncName":"genAverageClustering","categories":["algorithms","cluster"]},"genAverageClustering":{"name":"genAverageClustering","aliases":["genAverageClustering","algorithms.genAverageClustering","algorithms.cluster.genAverageClustering","cluster.genAverageClustering"],"syncName":"averageClustering","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","nullable":true},"typeAsHTML":"?Iterable","description":"(default: all nodes)\n  Compute average clustering for nodes in this container."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","description":"(default: null)\n  The edge attribute that holds the numerical value used as a weight.\n  If `null`, then each edge has weight `1`."},{"name":"optCountZeros","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"\nIf `false` include only the nodes with nonzero clustering in the average.","defaultValue":"true"}],"categories":["algorithms","cluster"]},"clustering":{"name":"clustering","aliases":["clustering","algorithms.clustering","algorithms.cluster.clustering","cluster.clustering"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","optional":true,"nullable":true},"typeAsHTML":"?Iterable=","description":"(default: all nodes)\n    Compute average clustering for nodes in this container."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","description":"(default: null)\nIf the edge attribute that holds the numerical value used as a weight.\nIf `null`, then each edge has weight `1`."}],"description":"Compute the clustering coefficient for nodes.\n\nFor unweighted graphs the clustering of each node `$u$`\nis the fraction of possible triangles through that node that exist,\n\n```math\nc_u = \\frac{2 T(u)}{deg(u)(deg(u)-1)}\n```\n\nwhere `$T(u)$` is the number of triangles through node `$u$` and `$deg(u)$`\nis the degree of `$u$`.\n\nFor weighted graphs the clustering is defined as the geometric average of\nthe subgraph edge weights,\n\n```math\nc_u = \\frac{1}{deg(u)(deg(u)-1)}\n      \\sum_{uv} (\\hat{w}_{uv} \\hat{w}_{uw} \\hat{w}_{vw})^{1/3}\n```\n\nThe edge weights `$\\hat{w}_{uv}$` are normalized by the maximum weight in the\nnetwork `$\\hat{w}_{uv} = w_{uv}/\\max(2)$`.\n\nThe value `$c_u$` is assigned to `$0$` if `$deg(u) < 2$`.\n\n### Example\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.clustering(G, 0);\n// 1\njsnx.clustering(G);\n// Map {0: 1, 1: 1, 2: 1, 3: 1, 4: 1}\n```","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}],"nullable":false},"typeAsHTML":"!(number|Map)","description":"Clustering coefficient at specified nodes"},"see":[],"async":false,"asyncName":"genClustering","categories":["algorithms","cluster"]},"genClustering":{"name":"genClustering","aliases":["genClustering","algorithms.genClustering","algorithms.cluster.genClustering","cluster.genClustering"],"syncName":"clustering","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"Iterable","optional":true,"nullable":true},"typeAsHTML":"?Iterable=","description":"(default: all nodes)\n    Compute average clustering for nodes in this container."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","description":"(default: null)\nIf the edge attribute that holds the numerical value used as a weight.\nIf `null`, then each edge has weight `1`."}],"categories":["algorithms","cluster"]},"transitivity":{"name":"transitivity","aliases":["transitivity","algorithms.transitivity","algorithms.cluster.transitivity","cluster.transitivity"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"}],"description":"Compute graph transitivity, the fraction of all possible triangles\npresent in G.\n\nPossible triangles are identified by the number of \"triads\"\n(two edges with a shared vertex).\n\nThe transitivity is\n\n```math\nT = 3\\frac{\\#triangles}{\\#triads}\n```\n\n### Example\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.transitivity(G);\n// 1\n```","returns":{"name":"Transitivity","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"asyncName":"genTransitivity","categories":["algorithms","cluster"]},"genTransitivity":{"name":"genTransitivity","aliases":["genTransitivity","algorithms.genTransitivity","algorithms.cluster.genTransitivity","cluster.genTransitivity"],"syncName":"transitivity","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"}],"categories":["algorithms","cluster"]},"squareClustering":{"name":"squareClustering","aliases":["squareClustering","algorithms.squareClustering","algorithms.cluster.squareClustering","cluster.squareClustering"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"opt_nodes","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default: all)\n Compute clustering for nodes in this container."}],"description":"Compute the squares clustering coefficient for nodes.\n\nFor each node return the faction of possible squares that exist at the node\n\n```math\nC_4(v) = \\frac{ \\sum_{u=1}^{k_v}\n\\sum_{w=u+1}^{k_v} q_v(u,w) }{ \\sum_{u=1}^{k_v}\n\\sum_{w=u+1}^{k_v} [a_v(u,w) + q_v(u,w)]}\n```\n\nwhere `$q_v(u,w)$` are the number of common neighbors of `$u$` and `$v$`\nother than `$v$` (i.e. squares), and\n`$a_v(u,w) = (k_u-(1+q_v(u,w)+\\theta_{uv}))(k_w-(1+q_v(u,w)+\\theta_{uw}))$`\nwhere `$\\theta_{uw} = 1$` if `$u$` and `$w$` are  connected and `$0$`\notherwise.\n\n### Examples\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.squareClustering(G, 0);\n// 1\njsnx.squareClustering(G);\n// Map {0: 1, 1: 1, 2: 1, 3: 1, 4: 1}\n```\n\n### Notes\n\nWhile `$C_3(v)$` (triangle clustering) gives the probability that\ntwo neighbors of node `$v$` are connected with each other, `$C_4(v)$` is\nthe probability that two neighbors of node `$v$` share a common\nneighbor different from `$v$`. This algorithm can be applied to both\nbipartite and unipartite networks.","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"number"}],"nullable":false},"typeAsHTML":"!(Map|number)","description":"A dictionary keyed by node with the square clustering coefficient value."},"see":[],"async":false,"asyncName":"genSquareClustering","categories":["algorithms","cluster"]},"genSquareClustering":{"name":"genSquareClustering","aliases":["genSquareClustering","algorithms.genSquareClustering","algorithms.cluster.genSquareClustering","cluster.genSquareClustering"],"syncName":"squareClustering","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"opt_nodes","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default: all)\n Compute clustering for nodes in this container."}],"categories":["algorithms","cluster"]},"isDirectedAcyclicGraph":{"name":"isDirectedAcyclicGraph","aliases":["isDirectedAcyclicGraph","algorithms.isDirectedAcyclicGraph","algorithms.dag.isDirectedAcyclicGraph","dag.isDirectedAcyclicGraph"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A graph"}],"description":"Return `true` if the graph G is a directed acyclic graph (DAG) or\n`false` if not.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"true of G is a DAG, false otherwise"},"see":[],"async":false,"asyncName":"genIsDirectedAcyclicGraph","categories":["algorithms","dag"]},"genIsDirectedAcyclicGraph":{"name":"genIsDirectedAcyclicGraph","aliases":["genIsDirectedAcyclicGraph","algorithms.genIsDirectedAcyclicGraph","algorithms.dag.genIsDirectedAcyclicGraph","dag.genIsDirectedAcyclicGraph"],"syncName":"isDirectedAcyclicGraph","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A graph"}],"categories":["algorithms","dag"]},"topologicalSort":{"name":"topologicalSort","aliases":["topologicalSort","algorithms.topologicalSort","algorithms.dag.topologicalSort","dag.topologicalSort"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A directed Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Explore graph in specified order given\n  in optNbunch."}],"description":"Return a list of nodes in topological sort order.\n\nA topological sort is a non-unique permutation of the nodes such that an edge\nfrom `$u$` to `$v$` implies that `$u$` appears before `$v$` in the\ntopological sort order.\n\n### Notes\n\nThis algorithm is based on a description and proof in\nThe Algorithm Design Manual ([1][]).\n\n### References\n\n\n[1] [Skiena, S. S. The Algorithm Design Manual  (Springer-Verlag, 1998).][1]\n[1]: http://www.amazon.com/exec/obidos/ASIN/0387948600/ref=ase_thealgorithmrepo/","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"},"see":"#is_directed_acyclic_graph","async":false,"asyncName":"genTopologicalSort","categories":["algorithms","dag"]},"genTopologicalSort":{"name":"genTopologicalSort","aliases":["genTopologicalSort","algorithms.genTopologicalSort","algorithms.dag.genTopologicalSort","dag.genTopologicalSort"],"syncName":"topologicalSort","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A directed Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Explore graph in specified order given\n  in optNbunch."}],"categories":["algorithms","dag"]},"topologicalSortRecursive":{"name":"topologicalSortRecursive","aliases":["topologicalSortRecursive","algorithms.topologicalSortRecursive","algorithms.dag.topologicalSortRecursive","dag.topologicalSortRecursive"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A directed Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Explore graph in specified order given\n  in optNbunch."}],"description":"Return a list of nodes in topological sort order.\n\nA topological sort is a non-unique permutation of the nodes such that an edge\nfrom `$u$` to `$v$` implies that `$u$` appears before `$v$` in the\ntopological sort order.\n\n### Notes\n\nThis is a recursive version of topological sort.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"},"see":["#topological_sort","#is_directed_acyclic_graph"],"async":false,"asyncName":"genTopologicalSortRecursive","categories":["algorithms","dag"]},"genTopologicalSortRecursive":{"name":"genTopologicalSortRecursive","aliases":["genTopologicalSortRecursive","algorithms.genTopologicalSortRecursive","algorithms.dag.genTopologicalSortRecursive","dag.genTopologicalSortRecursive"],"syncName":"topologicalSortRecursive","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A directed Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Explore graph in specified order given\n  in optNbunch."}],"categories":["algorithms","dag"]},"isAperiodic":{"name":"isAperiodic","aliases":["isAperiodic","algorithms.isAperiodic","algorithms.dag.isAperiodic","dag.isAperiodic"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Return true if G is aperiodic.\n\nA directed graph is aperiodic if there is no integer `$k > 1$` that\ndivides the length of every cycle in the graph.\n\n### Notes\n\nThis uses the method outlined in (1), which runs in `$O(m)$` time\ngiven `$m$` edges in `$G$`. Note that a graph is not aperiodic if it is\nacyclic as every integer trivial divides length `$0$` cycles.\n\n\n### References\n\n[1] Jarvis, J. P.; Shier, D. R. (1996),\n    Graph-theoretic analysis of finite Markov chains,\n    in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:\n    A Multidisciplinary Approach, CRC Press.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"true if the graph is aperiodic false otherwise"},"see":[],"async":false,"asyncName":"genIsAperiodic","categories":["algorithms","dag"]},"genIsAperiodic":{"name":"genIsAperiodic","aliases":["genIsAperiodic","algorithms.genIsAperiodic","algorithms.dag.genIsAperiodic","dag.genIsAperiodic"],"syncName":"isAperiodic","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","dag"]},"isGraphical":{"name":"isGraphical","aliases":["isGraphical","algorithms.isGraphical","algorithms.graphical.isGraphical","graphical.isGraphical"],"params":[{"name":"sequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A sequence of integer node degrees."},{"name":"optMethod","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"('eg' | 'hh')\n    The method used to validate the degree sequence.\n    \"eg\" corresponds to the Erdős-Gallai algorithm, and\n    \"hh\" to the Havel-Hakimi algorithm.","defaultValue":"'hh'"}],"description":"Returns `true` if `sequence` is a valid degree sequence.\nA degree sequence is valid if some graph can realize it.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(4);\nvar sequence = G.degree().values();\njsnx.isValidDegreeSequence(sequence);\n// true\n```","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"`true` if `sequence` is a valid degree sequence and `false` if not."},"see":[],"async":false,"asyncName":"genIsGraphical","categories":["algorithms","graphical"]},"genIsGraphical":{"name":"genIsGraphical","aliases":["genIsGraphical","algorithms.genIsGraphical","algorithms.graphical.genIsGraphical","graphical.genIsGraphical"],"syncName":"isGraphical","async":true,"params":[{"name":"sequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A sequence of integer node degrees."},{"name":"optMethod","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"('eg' | 'hh')\n    The method used to validate the degree sequence.\n    \"eg\" corresponds to the Erdős-Gallai algorithm, and\n    \"hh\" to the Havel-Hakimi algorithm.","defaultValue":"'hh'"}],"categories":["algorithms","graphical"]},"isValidDegreeSequence":{"name":"isValidDegreeSequence","aliases":["isValidDegreeSequence","algorithms.isValidDegreeSequence","algorithms.graphical.isValidDegreeSequence","graphical.isValidDegreeSequence"],"params":[{"name":"sequence"},{"name":"optMethod"}],"description":"","see":[],"aliasFor":"isGraphical","async":false,"asyncName":"genIsValidDegreeSequence","categories":["algorithms","graphical"]},"genIsValidDegreeSequence":{"name":"genIsValidDegreeSequence","aliases":["genIsValidDegreeSequence","algorithms.genIsValidDegreeSequence","algorithms.graphical.genIsValidDegreeSequence","graphical.genIsValidDegreeSequence"],"syncName":"isValidDegreeSequence","async":true,"params":[{"name":"sequence"},{"name":"optMethod"}],"categories":["algorithms","graphical"]},"isValidDegreeSequenceHavelHakimi":{"name":"isValidDegreeSequenceHavelHakimi","aliases":["isValidDegreeSequenceHavelHakimi","algorithms.isValidDegreeSequenceHavelHakimi","algorithms.graphical.isValidDegreeSequenceHavelHakimi","graphical.isValidDegreeSequenceHavelHakimi"],"params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nA list of integers where each element specifies the degree of a node\nin a graph."}],"description":"Returns `true` if `degreeSequence` cam be realized by a simple graph.\n\nThe Validation proceeds via the Havel-Hakimi theorem.\nWorst-case run time is `$O(s)$`, where `$s$` is the sum of the degree\nsequence.\n\nThe `$ZZ$` condition says that for the sequence `$d$`, if\n\n```math\n    |d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n```\n\nthen `$d$` is graphical.\n\n### References\n\n[1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n    of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"`true` if `degreeSequence` is graphical and `false` if not."},"see":[],"async":false,"asyncName":"genIsValidDegreeSequenceHavelHakimi","categories":["algorithms","graphical"]},"genIsValidDegreeSequenceHavelHakimi":{"name":"genIsValidDegreeSequenceHavelHakimi","aliases":["genIsValidDegreeSequenceHavelHakimi","algorithms.genIsValidDegreeSequenceHavelHakimi","algorithms.graphical.genIsValidDegreeSequenceHavelHakimi","graphical.genIsValidDegreeSequenceHavelHakimi"],"syncName":"isValidDegreeSequenceHavelHakimi","async":true,"params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nA list of integers where each element specifies the degree of a node\nin a graph."}],"categories":["algorithms","graphical"]},"isValidDegreeSequenceErdosGallai":{"name":"isValidDegreeSequenceErdosGallai","aliases":["isValidDegreeSequenceErdosGallai","algorithms.isValidDegreeSequenceErdosGallai","algorithms.graphical.isValidDegreeSequenceErdosGallai","graphical.isValidDegreeSequenceErdosGallai"],"params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nA list of integers where each element specifies the degree of a node\nin a graph."}],"description":"Returns `true` if `degreeSequence` can be realized by a simple graph.\nThe validation is done using the Erdős-Gallai theorem.\n\nThis implementation uses an equivalent form of the Erdős-Gallai criterion.\nWorst-case run time is `$O(n)$` where `$n$` is the length of the sequence.\n\nSpecifically, a sequence `$d$` is graphical if and only if the sum of the\nsequence is even and for all strong indices `$k$` in the sequence,\n\n```math\n\\sum_{i=1}^{k} d_i \\leq k(k-1) + \\sum_{j=k+1}^{n} \\min(d_i,k)\n   = k(n-1) - ( k \\sum_{j=0}^{k-1} n_j - \\sum_{j=0}^{k-1} j n_j )\n```\n\nA strong index `$k$` is any index where `$d_k \\geq k$` and the value `$n_j$`\nis the number of occurrences of `$j$` in `$d$`. The maximal strong index is\ncalled the Durfee index.\n\nThis particular rearrangement comes from the proof of Theorem 3 in (2)\n\nThe `$ZZ$` condition says that for the sequence `$d$`, if\n\n```math\n|d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n```\n\nthen `$d$` is graphical. This was shown in Theorem 6 in (2).\n\n### References\n[1] A. Tripathi and S. Vijay. \"A note on a theorem of Erdős & Gallai\",\n    Discrete Mathematics, 265, pp. 417-420 (2003).\n\n[2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n    of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"`true` if `degreeSequence` is graphical and f`alse` if not."},"see":[],"async":false,"asyncName":"genIsValidDegreeSequenceErdosGallai","categories":["algorithms","graphical"]},"genIsValidDegreeSequenceErdosGallai":{"name":"genIsValidDegreeSequenceErdosGallai","aliases":["genIsValidDegreeSequenceErdosGallai","algorithms.genIsValidDegreeSequenceErdosGallai","algorithms.graphical.genIsValidDegreeSequenceErdosGallai","graphical.genIsValidDegreeSequenceErdosGallai"],"syncName":"isValidDegreeSequenceErdosGallai","async":true,"params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nA list of integers where each element specifies the degree of a node\nin a graph."}],"categories":["algorithms","graphical"]},"couldBeIsomorphic":{"name":"couldBeIsomorphic","aliases":["couldBeIsomorphic","algorithms.couldBeIsomorphic","algorithms.isomorphism.couldBeIsomorphic","algorithms.isomorphism.isomorph.couldBeIsomorphic","algorithms.isomorph.couldBeIsomorphic","isomorphism.couldBeIsomorphic","isomorphism.isomorph.couldBeIsomorphic","isomorph.couldBeIsomorphic"],"params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"description":"Returns `false` if graphs are definitely not isomorphic.\n`true` does **not** guarantee isomorphism.\n\nChecks for matching degree, triangle, and number of cliques sequences.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"`false` if graphs are definitely not isomorphic."},"see":[],"async":false,"asyncName":"genCouldBeIsomorphic","categories":["algorithms","isomorphism","isomorph"]},"genCouldBeIsomorphic":{"name":"genCouldBeIsomorphic","aliases":["genCouldBeIsomorphic","algorithms.genCouldBeIsomorphic","algorithms.isomorphism.genCouldBeIsomorphic","algorithms.isomorphism.isomorph.genCouldBeIsomorphic","algorithms.isomorph.genCouldBeIsomorphic","isomorphism.genCouldBeIsomorphic","isomorphism.isomorph.genCouldBeIsomorphic","isomorph.genCouldBeIsomorphic"],"syncName":"couldBeIsomorphic","async":true,"params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"categories":["algorithms","isomorphism","isomorph"]},"fastCouldBeIsomorphic":{"name":"fastCouldBeIsomorphic","aliases":["fastCouldBeIsomorphic","algorithms.fastCouldBeIsomorphic","algorithms.isomorphism.fastCouldBeIsomorphic","algorithms.isomorphism.isomorph.fastCouldBeIsomorphic","algorithms.isomorph.fastCouldBeIsomorphic","isomorphism.fastCouldBeIsomorphic","isomorphism.isomorph.fastCouldBeIsomorphic","isomorph.fastCouldBeIsomorphic"],"params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"description":"Returns `false` if graphs are definitely not isomorphic.\n`true` does **not** guarantee isomorphism.\n\nChecks for matching degree and triangle sequences.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"`false` if graphs are definitely not isomorphic."},"see":[],"async":false,"asyncName":"genFastCouldBeIsomorphic","categories":["algorithms","isomorphism","isomorph"]},"genFastCouldBeIsomorphic":{"name":"genFastCouldBeIsomorphic","aliases":["genFastCouldBeIsomorphic","algorithms.genFastCouldBeIsomorphic","algorithms.isomorphism.genFastCouldBeIsomorphic","algorithms.isomorphism.isomorph.genFastCouldBeIsomorphic","algorithms.isomorph.genFastCouldBeIsomorphic","isomorphism.genFastCouldBeIsomorphic","isomorphism.isomorph.genFastCouldBeIsomorphic","isomorph.genFastCouldBeIsomorphic"],"syncName":"fastCouldBeIsomorphic","async":true,"params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"categories":["algorithms","isomorphism","isomorph"]},"fasterCouldBeIsomorphic":{"name":"fasterCouldBeIsomorphic","aliases":["fasterCouldBeIsomorphic","algorithms.fasterCouldBeIsomorphic","algorithms.isomorphism.fasterCouldBeIsomorphic","algorithms.isomorphism.isomorph.fasterCouldBeIsomorphic","algorithms.isomorph.fasterCouldBeIsomorphic","isomorphism.fasterCouldBeIsomorphic","isomorphism.isomorph.fasterCouldBeIsomorphic","isomorph.fasterCouldBeIsomorphic"],"params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"description":"Returns `false` if graphs are definitely not isomorphic.\n`true` does **not** guarantee isomorphism.\n\nChecks for matching degree sequences.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"False if graphs are definitely not isomorphic."},"see":[],"async":false,"asyncName":"genFasterCouldBeIsomorphic","categories":["algorithms","isomorphism","isomorph"]},"genFasterCouldBeIsomorphic":{"name":"genFasterCouldBeIsomorphic","aliases":["genFasterCouldBeIsomorphic","algorithms.genFasterCouldBeIsomorphic","algorithms.isomorphism.genFasterCouldBeIsomorphic","algorithms.isomorphism.isomorph.genFasterCouldBeIsomorphic","algorithms.isomorph.genFasterCouldBeIsomorphic","isomorphism.genFasterCouldBeIsomorphic","isomorphism.isomorph.genFasterCouldBeIsomorphic","isomorph.genFasterCouldBeIsomorphic"],"syncName":"fasterCouldBeIsomorphic","async":true,"params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"categories":["algorithms","isomorphism","isomorph"]},"union":{"name":"union","aliases":["union","algorithms.union","algorithms.operators.union","algorithms.operators.binary.union","algorithms.binary.union","operators.union","operators.binary.union","binary.union"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"rename"},"value":{"type":"NameExpression","name":"Array","nullable":true}}]},"typeAsHTML":"{rename: ?Array}","description":"\n- rename: Node names `G` and `H` can be changed by specifying the tuple\n  `['G-', 'H-']` (for example). Node `'u'` in `G` is then renamed to\n  `'G-u'` and `'v'` in `H` is renamed to `'H-v'`.","defaultValue":"{}"}],"async":false,"description":"Return the union of graphs `G` and `H`.\n\nGraphs `G` and `H` must be disjoint, otherwise an exception is raised.\n\n### Notes\n\nTo force a disjoint union with node relabeling, use `disjointUnion(G, H)` or\n`convertNodeLabelsToIntegers()`.\n\nGraph, edge and node attributes are propagated from `G` and `H` to the union\nGraph. If a graph attribute is present in both `G` and `H`, the value from\n`H` is used.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A union graph with the same type as G"},"see":"#disjointUnion","asyncName":"genUnion","categories":["algorithms","operators","binary"]},"genUnion":{"name":"genUnion","aliases":["genUnion","algorithms.genUnion","algorithms.operators.genUnion","algorithms.operators.binary.genUnion","algorithms.binary.genUnion","operators.genUnion","operators.binary.genUnion","binary.genUnion"],"syncName":"union","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"rename"},"value":{"type":"NameExpression","name":"Array","nullable":true}}]},"typeAsHTML":"{rename: ?Array}","description":"\n- rename: Node names `G` and `H` can be changed by specifying the tuple\n  `['G-', 'H-']` (for example). Node `'u'` in `G` is then renamed to\n  `'G-u'` and `'v'` in `H` is renamed to `'H-v'`.","defaultValue":"{}"}],"categories":["algorithms","operators","binary"]},"disjointUnion":{"name":"disjointUnion","aliases":["disjointUnion","algorithms.disjointUnion","algorithms.operators.disjointUnion","algorithms.operators.binary.disjointUnion","algorithms.binary.disjointUnion","operators.disjointUnion","operators.binary.disjointUnion","binary.disjointUnion"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Return the disjoint union of graphs `G` and `H`.\n\nThis algorithm forces distinct integer node labels.\n\n### Notes\n\nA new graph is created, of the same class as `G`.  It is recommended that `G`\nand `H` be either both directed or both undirected.\n\nThe nodes of `G` are relabeled `0` to `numberOfNodes(G) - 1`, and the nodes\nof `H` are relabeled `numberOfNodes(G)` to\n`numberOfNodes(G) + numberOfNodes(H) - 1`.\n\nGraph, edge, and node attributes are propagated from `G` and `H` to the union\ngraph. If a graph attribute is present in both `G` and `H` the value from `H`\nis used.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A union graph with the same type as G."},"see":[],"async":false,"asyncName":"genDisjointUnion","categories":["algorithms","operators","binary"]},"genDisjointUnion":{"name":"genDisjointUnion","aliases":["genDisjointUnion","algorithms.genDisjointUnion","algorithms.operators.genDisjointUnion","algorithms.operators.binary.genDisjointUnion","algorithms.binary.genDisjointUnion","operators.genDisjointUnion","operators.binary.genDisjointUnion","binary.genDisjointUnion"],"syncName":"disjointUnion","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","operators","binary"]},"intersection":{"name":"intersection","aliases":["intersection","algorithms.intersection","algorithms.operators.intersection","algorithms.operators.binary.intersection","algorithms.binary.intersection","operators.intersection","operators.binary.intersection","binary.intersection"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Return a new graph that contains only edges that exist in both `G` and `H`.\n\nThe node set of `H` and `G` must be the same.\n\n### Notes\n\nAttributes from the graph, nodes and edges are not copied to the new graph.\nIf you want a new graph of the intersection of `G` and `H` with the\nattributes, (including edge data) from `G` use `removeNode()` as follows\n\n```\nvar G = jsnx.pathGraph(3);\nvar H = jsnx.pathGraph(5);\nvar R = G.copy();\nfor (var n of G) {\n  if (!H.hasNode(n)) {\n    R.removeNode(n);\n  }\n}\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A new graph with the same types as G"},"see":[],"async":false,"asyncName":"genIntersection","categories":["algorithms","operators","binary"]},"genIntersection":{"name":"genIntersection","aliases":["genIntersection","algorithms.genIntersection","algorithms.operators.genIntersection","algorithms.operators.binary.genIntersection","algorithms.binary.genIntersection","operators.genIntersection","operators.binary.genIntersection","binary.genIntersection"],"syncName":"intersection","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","operators","binary"]},"difference":{"name":"difference","aliases":["difference","algorithms.difference","algorithms.operators.difference","algorithms.operators.binary.difference","algorithms.binary.difference","operators.difference","operators.binary.difference","binary.difference"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Return a new graph that contains the edges that exist in `G` but not in `H`.\n\nThe node sets of `H` and `G` must be the same.\n\n### Notes\n\nAttributes from the graph, nodes and edges are not copied to the new graph.\nIf you want a new graph of the difference of `G` and `H` with the attributes\n(including edge data) from `G`, use `removeNodes()` as follows:\n\n```\nvar G = jsnx.pathGraph(3);\nvar H = jsnx.pathGraph(5);\nvar R = G.copy();\nfor (var n of G) {\n  if (!H.hasNode(n)) {\n    R.removeNode(n);\n  }\n}\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A new graph with the same types as G"},"see":[],"async":false,"asyncName":"genDifference","categories":["algorithms","operators","binary"]},"genDifference":{"name":"genDifference","aliases":["genDifference","algorithms.genDifference","algorithms.operators.genDifference","algorithms.operators.binary.genDifference","algorithms.binary.genDifference","operators.genDifference","operators.binary.genDifference","binary.genDifference"],"syncName":"difference","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","operators","binary"]},"symmetricDifference":{"name":"symmetricDifference","aliases":["symmetricDifference","algorithms.symmetricDifference","algorithms.operators.symmetricDifference","algorithms.operators.binary.symmetricDifference","algorithms.binary.symmetricDifference","operators.symmetricDifference","operators.binary.symmetricDifference","binary.symmetricDifference"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"async":false,"description":"Return new graph with edges that exit in either `G` or `H` but not both.\n\nThe node sets of `H` and `G` must be the same.\n\n### Notes\n\nAttributes from the graph, nodes and edges are not copied to the new graph.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A new graph with the same types as G"},"see":[],"asyncName":"genSymmetricDifference","categories":["algorithms","operators","binary"]},"genSymmetricDifference":{"name":"genSymmetricDifference","aliases":["genSymmetricDifference","algorithms.genSymmetricDifference","algorithms.operators.genSymmetricDifference","algorithms.operators.binary.genSymmetricDifference","algorithms.binary.genSymmetricDifference","operators.genSymmetricDifference","operators.binary.genSymmetricDifference","binary.genSymmetricDifference"],"syncName":"symmetricDifference","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","operators","binary"]},"compose":{"name":"compose","aliases":["compose","algorithms.compose","algorithms.operators.compose","algorithms.operators.binary.compose","algorithms.binary.compose","operators.compose","operators.binary.compose","binary.compose"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Return a new graph of `G` composed with `H`.\n\nComposition is the simple union of the node sets and edge sets. The node sets\nof `G` and `H` do not need to be disjoint.\n\n### Notes\n\nIt is recommended that `G` and `H` be either both directed or both\nundirected. Attributes from `H` take precedent over attributes from `G`.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A new graph with the same type as G"},"see":[],"async":false,"asyncName":"genCompose","categories":["algorithms","operators","binary"]},"genCompose":{"name":"genCompose","aliases":["genCompose","algorithms.genCompose","algorithms.operators.genCompose","algorithms.operators.binary.genCompose","algorithms.binary.genCompose","operators.genCompose","operators.binary.genCompose","binary.genCompose"],"syncName":"compose","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"H","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"categories":["algorithms","operators","binary"]},"hasPath":{"name":"hasPath","aliases":["hasPath","algorithms.hasPath","algorithms.shortestPaths.hasPath","algorithms.shortestPaths.generic.hasPath","algorithms.generic.hasPath","shortestPaths.hasPath","shortestPaths.generic.hasPath","generic.hasPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"node"}}]},"typeAsHTML":"{source: Node, target: node}","description":"\n- source: Starting node for path\n- target: Ending node for path"}],"description":"Return `true` if `G` has a path from `source to `target`, `false` otherwise.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"},"see":[],"async":false,"asyncName":"genHasPath","categories":["algorithms","shortestPaths","generic"]},"genHasPath":{"name":"genHasPath","aliases":["genHasPath","algorithms.genHasPath","algorithms.shortestPaths.genHasPath","algorithms.shortestPaths.generic.genHasPath","algorithms.generic.genHasPath","shortestPaths.genHasPath","shortestPaths.generic.genHasPath","generic.genHasPath"],"syncName":"hasPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"node"}}]},"typeAsHTML":"{source: Node, target: node}","description":"\n- source: Starting node for path\n- target: Ending node for path"}],"categories":["algorithms","shortestPaths","generic"]},"shortestPath":{"name":"shortestPath","aliases":["shortestPath","algorithms.shortestPath","algorithms.shortestPaths.shortestPath","algorithms.shortestPaths.generic.shortestPath","algorithms.generic.shortestPath","shortestPaths.shortestPath","shortestPaths.generic.shortestPath","generic.shortestPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}],"optional":true,"nullable":true},"typeAsHTML":"?{source: ?Node, target: ?Node, weight: ?string}=","description":"\n- source: Starting node for path.\n  If not specified, compute the shortest paths using all nodes as source\n  nodes.\n- target: Ending node for path.\n  If not specified, compute the shortest paths using all nodes as target\n  nodes.\n- weight:\n  If not specified, every edge has weight/distance/cost of 1.\n  If a string, use this edge attribute as the edge weight. Any edg\n  attribute not present defaults to 1.","defaultValue":"{}"}],"description":"Compute shortest paths in the graph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\njsnx.shortestPath(G, {source: 0, target: 4});\n// [0, 1, 2, 3, 4]\nvar paths = jsnx.shortestPath(G, {source: 0}); // target not specified\npaths.get(4);\n// [0, 1, 2, 3, 4]\npaths = jsnx.shortestPath(G {target: 4}); // source not specified\npaths.get(0);\n// [0, 1, 2, 3, 4]\npaths = jsnx.shortestPath(G); // source, target not specified\npaths.get(0).get(4);\n// [0, 1, 2, 3, 4]\n```\n\n### Notes\n\nThere may be more than one shortest path between a source and a target.\nThis returns only one of them.","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Array"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(Array|Map)","description":"All returned paths include both the source and the\n target in the path.\n\n If the `source` and `target` are both specified, return a single list\n of nodes in a shortest path from the source to the target.\n\n If only the `source` is specified, return a Map keyed by\n targets with a list of nodes in a shortest path from the source\n to one of the targets.\n\n If only the `target` is specified, return a Map keyed by\n sources with a list of nodes in a shortest path from one of the\n sources to the target.\n\n If neither the `source` nor `target` are specified return a Map\n of Maps with `Map {source: Map {target: [list of nodes in path] }}`."},"see":["allPairsShortestPath","allPairsDijkstraPath","singleSourceShortestPath","singleSourceDijkstraPath"],"async":false,"asyncName":"genShortestPath","categories":["algorithms","shortestPaths","generic"]},"genShortestPath":{"name":"genShortestPath","aliases":["genShortestPath","algorithms.genShortestPath","algorithms.shortestPaths.genShortestPath","algorithms.shortestPaths.generic.genShortestPath","algorithms.generic.genShortestPath","shortestPaths.genShortestPath","shortestPaths.generic.genShortestPath","generic.genShortestPath"],"syncName":"shortestPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}],"optional":true,"nullable":true},"typeAsHTML":"?{source: ?Node, target: ?Node, weight: ?string}=","description":"\n- source: Starting node for path.\n  If not specified, compute the shortest paths using all nodes as source\n  nodes.\n- target: Ending node for path.\n  If not specified, compute the shortest paths using all nodes as target\n  nodes.\n- weight:\n  If not specified, every edge has weight/distance/cost of 1.\n  If a string, use this edge attribute as the edge weight. Any edg\n  attribute not present defaults to 1.","defaultValue":"{}"}],"categories":["algorithms","shortestPaths","generic"]},"shortestPathLength":{"name":"shortestPathLength","aliases":["shortestPathLength","algorithms.shortestPathLength","algorithms.shortestPaths.shortestPathLength","algorithms.shortestPaths.generic.shortestPathLength","algorithms.generic.shortestPathLength","shortestPaths.shortestPathLength","shortestPaths.generic.shortestPathLength","generic.shortestPathLength"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}],"optional":true,"nullable":true},"typeAsHTML":"?{source: ?Node, target: ?Node, weight: ?string}=","description":"\n- source: Starting node for path.\n  If not specified, compute the shortest path lengths using all nodes as\n  source nodes.\n- target: Ending node for path.\n  If not specified, compute the shortest path length using all nodes as\n  target nodes.\n- weight:\n  If not specified, every edge has weight/distance/cost of 1.\n  If a string, use this edge attribute as the edge weight. Any edg\n  attribute not present defaults to 1.","defaultValue":"{}"}],"description":"Compute shortest path lengths in the graph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\njsnx.shortestPathLength(G, {source: 0, target: 4});\n// 4\nvar paths = jsnx.shortestPathLength(G, {source: 0}); // target not specified\npaths.get(4);\n// 4\npaths = jsnx.shortestPathLength(G {target: 4}); // source not specified\npaths.get(0);\n// 4\npaths = jsnx.shortestPathLength(G); // source, target not specified\npaths.get(0).get(4);\n// 4\n```\n\n### Notes\n\nThe length of the path is always 1 less than the number of nodes involved in\nthe path since the length measures the number of edges followed.\n\nFor digraphs this returns the shortest directed path length. To find path\nlengths in the reverse directio, use `G.reverse(false)` first to flip the\nedge orientation.","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","description":"If the `source` and `target` are both specified, return the length of the\n shortest path from the source to the target.\n\n If only the `source` is specified, return a Map keyed by\n targets whose values are the lengths of the shortest path from the source\n to one of the targets.\n\n If only the `target` is specified, return a Map keyed by\n sources whose values are the lengths of the shortest path from one of the\n sources to the target.\n\n If neither the `source` nor `target` are specified return a Map\n of Maps with path[source][target]=L, where L is the length of the shortest\n path from source to target."},"see":["allPairsShortestPathLength","allPairsDijkstraPathLength","singleSourceShortestPathLength","singleSourceDijkstraPathLength"],"async":false,"asyncName":"genShortestPathLength","categories":["algorithms","shortestPaths","generic"]},"genShortestPathLength":{"name":"genShortestPathLength","aliases":["genShortestPathLength","algorithms.genShortestPathLength","algorithms.shortestPaths.genShortestPathLength","algorithms.shortestPaths.generic.genShortestPathLength","algorithms.generic.genShortestPathLength","shortestPaths.genShortestPathLength","shortestPaths.generic.genShortestPathLength","generic.genShortestPathLength"],"syncName":"shortestPathLength","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}],"optional":true,"nullable":true},"typeAsHTML":"?{source: ?Node, target: ?Node, weight: ?string}=","description":"\n- source: Starting node for path.\n  If not specified, compute the shortest path lengths using all nodes as\n  source nodes.\n- target: Ending node for path.\n  If not specified, compute the shortest path length using all nodes as\n  target nodes.\n- weight:\n  If not specified, every edge has weight/distance/cost of 1.\n  If a string, use this edge attribute as the edge weight. Any edg\n  attribute not present defaults to 1.","defaultValue":"{}"}],"categories":["algorithms","shortestPaths","generic"]},"singleSourceShortestPathLength":{"name":"singleSourceShortestPathLength","aliases":["singleSourceShortestPathLength","algorithms.singleSourceShortestPathLength","algorithms.shortestPaths.singleSourceShortestPathLength","algorithms.shortestPaths.unweighted.singleSourceShortestPathLength","algorithms.unweighted.singleSourceShortestPathLength","shortestPaths.singleSourceShortestPathLength","shortestPaths.unweighted.singleSourceShortestPathLength","unweighted.singleSourceShortestPathLength"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Starting node for path"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"\nDepth to stop the search. Only paths of length <= cutoff are returned."}],"description":"Compute the shortest path lengths from source to all reachable nodes.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar length = jsnx.singleSourceShortestPathLength(G, 0);\nlength.get(4);\n// 4\nlength\n// Map {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","description":"Map of shortest path lengths keyed by target."},"see":"shortestPathLength","async":false,"asyncName":"genSingleSourceShortestPathLength","categories":["algorithms","shortestPaths","unweighted"]},"genSingleSourceShortestPathLength":{"name":"genSingleSourceShortestPathLength","aliases":["genSingleSourceShortestPathLength","algorithms.genSingleSourceShortestPathLength","algorithms.shortestPaths.genSingleSourceShortestPathLength","algorithms.shortestPaths.unweighted.genSingleSourceShortestPathLength","algorithms.unweighted.genSingleSourceShortestPathLength","shortestPaths.genSingleSourceShortestPathLength","shortestPaths.unweighted.genSingleSourceShortestPathLength","unweighted.genSingleSourceShortestPathLength"],"syncName":"singleSourceShortestPathLength","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Starting node for path"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"\nDepth to stop the search. Only paths of length <= cutoff are returned."}],"categories":["algorithms","shortestPaths","unweighted"]},"allPairsShortestPathLength":{"name":"allPairsShortestPathLength","aliases":["allPairsShortestPathLength","algorithms.allPairsShortestPathLength","algorithms.shortestPaths.allPairsShortestPathLength","algorithms.shortestPaths.unweighted.allPairsShortestPathLength","algorithms.unweighted.allPairsShortestPathLength","shortestPaths.allPairsShortestPathLength","shortestPaths.unweighted.allPairsShortestPathLength","unweighted.allPairsShortestPathLength"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"depth to stop the search.\n Only paths of length <= cutoff are returned."}],"description":"Compute the shortest path lengths between all nodes in G.\n\nThe map returned only has keys for reachable node pairs.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar length = jsnx.allPairsShortestPathLength(G);\nlength.get(1).get(4);\n// 3\nlength.get(1);\n// Map {0: 1, 1: 0, 2: 1, 3: 2, 4: 3}\n```","returns":{"type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map"},"see":[],"async":false,"asyncName":"genAllPairsShortestPathLength","categories":["algorithms","shortestPaths","unweighted"]},"genAllPairsShortestPathLength":{"name":"genAllPairsShortestPathLength","aliases":["genAllPairsShortestPathLength","algorithms.genAllPairsShortestPathLength","algorithms.shortestPaths.genAllPairsShortestPathLength","algorithms.shortestPaths.unweighted.genAllPairsShortestPathLength","algorithms.unweighted.genAllPairsShortestPathLength","shortestPaths.genAllPairsShortestPathLength","shortestPaths.unweighted.genAllPairsShortestPathLength","unweighted.genAllPairsShortestPathLength"],"syncName":"allPairsShortestPathLength","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"depth to stop the search.\n Only paths of length <= cutoff are returned."}],"categories":["algorithms","shortestPaths","unweighted"]},"bidirectionalShortestPath":{"name":"bidirectionalShortestPath","aliases":["bidirectionalShortestPath","algorithms.bidirectionalShortestPath","algorithms.shortestPaths.bidirectionalShortestPath","algorithms.shortestPaths.unweighted.bidirectionalShortestPath","algorithms.unweighted.bidirectionalShortestPath","shortestPaths.bidirectionalShortestPath","shortestPaths.unweighted.bidirectionalShortestPath","unweighted.bidirectionalShortestPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"starting node for path"},{"name":"target","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"ending node for path"}],"description":"Return a list of nodes in a shortest path between source and target.\n\nThis algorithm is used by `shortestPath(G, source, target)`.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"},"see":"shortestPath","async":false,"asyncName":"genBidirectionalShortestPath","categories":["algorithms","shortestPaths","unweighted"]},"genBidirectionalShortestPath":{"name":"genBidirectionalShortestPath","aliases":["genBidirectionalShortestPath","algorithms.genBidirectionalShortestPath","algorithms.shortestPaths.genBidirectionalShortestPath","algorithms.shortestPaths.unweighted.genBidirectionalShortestPath","algorithms.unweighted.genBidirectionalShortestPath","shortestPaths.genBidirectionalShortestPath","shortestPaths.unweighted.genBidirectionalShortestPath","unweighted.genBidirectionalShortestPath"],"syncName":"bidirectionalShortestPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"starting node for path"},{"name":"target","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"ending node for path"}],"categories":["algorithms","shortestPaths","unweighted"]},"singleSourceShortestPath":{"name":"singleSourceShortestPath","aliases":["singleSourceShortestPath","algorithms.singleSourceShortestPath","algorithms.shortestPaths.singleSourceShortestPath","algorithms.shortestPaths.unweighted.singleSourceShortestPath","algorithms.unweighted.singleSourceShortestPath","shortestPaths.singleSourceShortestPath","shortestPaths.unweighted.singleSourceShortestPath","unweighted.singleSourceShortestPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"Depth to stop the search.\n  Only paths of `length <= cutoff` are returned."}],"description":"Compute shortest path between source and all other nodes reachable from\nsource.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.singleSourceShortestPath(G, 0);\npath.get(4);\n// [1, 2, 3, 4]\n```\n\n### Notes\n\nThe shortest path is not necessarily unique. So there can be multiple⋅\npaths between the source and each target node, all of which have the⋅\nsame 'shortest' length. For each target node, this function returns⋅\nonly one of those paths.\n","returns":{"name":"","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Map"},"applications":[{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!Map.&lt;Array>","description":"Map, keyed by target, of shortest paths."},"see":"shortestPath","async":false,"asyncName":"genSingleSourceShortestPath","categories":["algorithms","shortestPaths","unweighted"]},"genSingleSourceShortestPath":{"name":"genSingleSourceShortestPath","aliases":["genSingleSourceShortestPath","algorithms.genSingleSourceShortestPath","algorithms.shortestPaths.genSingleSourceShortestPath","algorithms.shortestPaths.unweighted.genSingleSourceShortestPath","algorithms.unweighted.genSingleSourceShortestPath","shortestPaths.genSingleSourceShortestPath","shortestPaths.unweighted.genSingleSourceShortestPath","unweighted.genSingleSourceShortestPath"],"syncName":"singleSourceShortestPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"Depth to stop the search.\n  Only paths of `length <= cutoff` are returned."}],"categories":["algorithms","shortestPaths","unweighted"]},"allPairsShortestPath":{"name":"allPairsShortestPath","aliases":["allPairsShortestPath","algorithms.allPairsShortestPath","algorithms.shortestPaths.allPairsShortestPath","algorithms.shortestPaths.unweighted.allPairsShortestPath","algorithms.unweighted.allPairsShortestPath","shortestPaths.allPairsShortestPath","shortestPaths.unweighted.allPairsShortestPath","unweighted.allPairsShortestPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"Depth to stop the search.\n  Only paths of length <= cutoff are returned."}],"description":"Compute shortest paths between all nodes.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.allPairsShortestPath(G);\npath.get(0).get(4);\n// [0, 1, 2, 3, 4]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","description":"Map, keyed by source and target, of shortest paths."},"see":"floydWarshall","async":false,"asyncName":"genAllPairsShortestPath","categories":["algorithms","shortestPaths","unweighted"]},"genAllPairsShortestPath":{"name":"genAllPairsShortestPath","aliases":["genAllPairsShortestPath","algorithms.genAllPairsShortestPath","algorithms.shortestPaths.genAllPairsShortestPath","algorithms.shortestPaths.unweighted.genAllPairsShortestPath","algorithms.unweighted.genAllPairsShortestPath","shortestPaths.genAllPairsShortestPath","shortestPaths.unweighted.genAllPairsShortestPath","unweighted.genAllPairsShortestPath"],"syncName":"allPairsShortestPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","description":"Depth to stop the search.\n  Only paths of length <= cutoff are returned."}],"categories":["algorithms","shortestPaths","unweighted"]},"predecessor":{"name":"predecessor","aliases":["predecessor","algorithms.predecessor","algorithms.shortestPaths.predecessor","algorithms.shortestPaths.unweighted.predecessor","algorithms.unweighted.predecessor","shortestPaths.predecessor","shortestPaths.unweighted.predecessor","unweighted.predecessor"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Starting node for path"},{"name":"optArgs","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number"}},{"type":"FieldType","key":{"type":"NameExpression","name":"returnSeen"},"value":{"type":"NameExpression","name":"boolean"}}]},"typeAsHTML":"{target: Node, cutoff: number, returnSeen: boolean}","description":"\n- `target(=null)`: If provided only predecessors between⋅source and target\n  are returned\n- `cutoff`: Depth to stop the search. Only paths of `length <= cutoff` are\n  returned\n- `returnSeen(=false)`: If `true`, return `(seenNodes, predecessors)`","defaultValue":"{}"}],"description":"Returns a map of predecessors for the path from source to all nodes in G.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(4);\nG.nodes();\n// [0, 1, 2, 3, 4]\njsnx.predecessor(G, 0);\n// Map {0: [], 1: [0], 2: [1], 3: [2]}","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!(Map|Array)","description":"Map, keyed by node, of predecessors in the shortest\n path."},"see":[],"async":false,"asyncName":"genPredecessor","categories":["algorithms","shortestPaths","unweighted"]},"genPredecessor":{"name":"genPredecessor","aliases":["genPredecessor","algorithms.genPredecessor","algorithms.shortestPaths.genPredecessor","algorithms.shortestPaths.unweighted.genPredecessor","algorithms.unweighted.genPredecessor","shortestPaths.genPredecessor","shortestPaths.unweighted.genPredecessor","unweighted.genPredecessor"],"syncName":"predecessor","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Starting node for path"},{"name":"optArgs","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number"}},{"type":"FieldType","key":{"type":"NameExpression","name":"returnSeen"},"value":{"type":"NameExpression","name":"boolean"}}]},"typeAsHTML":"{target: Node, cutoff: number, returnSeen: boolean}","description":"\n- `target(=null)`: If provided only predecessors between⋅source and target\n  are returned\n- `cutoff`: Depth to stop the search. Only paths of `length <= cutoff` are\n  returned\n- `returnSeen(=false)`: If `true`, return `(seenNodes, predecessors)`","defaultValue":"{}"}],"categories":["algorithms","shortestPaths","unweighted"]},"dijkstraPath":{"name":"dijkstraPath","aliases":["dijkstraPath","algorithms.dijkstraPath","algorithms.shortestPaths.dijkstraPath","algorithms.shortestPaths.weighted.dijkstraPath","algorithms.weighted.dijkstraPath","shortestPaths.dijkstraPath","shortestPaths.weighted.dijkstraPath","weighted.dijkstraPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{source: Node, target: Node, weight: ?string}","description":"\n- source: Starting node\n- target: Ending node\n- weight(='weight'): Edge data key corresponding to the edge weight"}],"description":"Returns the shortest path from `source` to `target` in a weighted graph G.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\njsnx.dijkstraPath(G, {source: 0, target: 4});\n// [0, 1, 2, 3, 4]\n```\n\n### Notes\n\nEdge weight attributes must be numerical. Distances are calculated as sums\nof weighted edges traversed.","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"List of nodes in a shortest path"},"see":"bidirectionalDijkstra","async":false,"asyncName":"genDijkstraPath","categories":["algorithms","shortestPaths","weighted"]},"genDijkstraPath":{"name":"genDijkstraPath","aliases":["genDijkstraPath","algorithms.genDijkstraPath","algorithms.shortestPaths.genDijkstraPath","algorithms.shortestPaths.weighted.genDijkstraPath","algorithms.weighted.genDijkstraPath","shortestPaths.genDijkstraPath","shortestPaths.weighted.genDijkstraPath","weighted.genDijkstraPath"],"syncName":"dijkstraPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{source: Node, target: Node, weight: ?string}","description":"\n- source: Starting node\n- target: Ending node\n- weight(='weight'): Edge data key corresponding to the edge weight"}],"categories":["algorithms","shortestPaths","weighted"]},"dijkstraPathLength":{"name":"dijkstraPathLength","aliases":["dijkstraPathLength","algorithms.dijkstraPathLength","algorithms.shortestPaths.dijkstraPathLength","algorithms.shortestPaths.weighted.dijkstraPathLength","algorithms.weighted.dijkstraPathLength","shortestPaths.dijkstraPathLength","shortestPaths.weighted.dijkstraPathLength","weighted.dijkstraPathLength"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{source: Node, target: Node, weight: ?string}","description":"\n- source: Starting node\n- target: Ending node\n- weight(='weight'): Edge data key corresponding to the edge weight"}],"description":"Returns the shortest path length from `source` to `target` in a weighted\ngraph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\njsnx.dijkstraPathLength(G, {source: 0, target: 4});\n// 4\n```\n\n### Notes\n\nEdge weight attributes must be numerical. Distances are calculated as sums\nof weighted edges traversed.","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Shortest path length"},"see":"bidirectionalDijkstra","async":false,"asyncName":"genDijkstraPathLength","categories":["algorithms","shortestPaths","weighted"]},"genDijkstraPathLength":{"name":"genDijkstraPathLength","aliases":["genDijkstraPathLength","algorithms.genDijkstraPathLength","algorithms.shortestPaths.genDijkstraPathLength","algorithms.shortestPaths.weighted.genDijkstraPathLength","algorithms.weighted.genDijkstraPathLength","shortestPaths.genDijkstraPathLength","shortestPaths.weighted.genDijkstraPathLength","weighted.genDijkstraPathLength"],"syncName":"dijkstraPathLength","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{source: Node, target: Node, weight: ?string}","description":"\n- source: Starting node\n- target: Ending node\n- weight(='weight'): Edge data key corresponding to the edge weight"}],"categories":["algorithms","shortestPaths","weighted"]},"singleSourceDijkstraPath":{"name":"singleSourceDijkstraPath","aliases":["singleSourceDijkstraPath","algorithms.singleSourceDijkstraPath","algorithms.shortestPaths.singleSourceDijkstraPath","algorithms.shortestPaths.weighted.singleSourceDijkstraPath","algorithms.weighted.singleSourceDijkstraPath","shortestPaths.singleSourceDijkstraPath","shortestPaths.weighted.singleSourceDijkstraPath","weighted.singleSourceDijkstraPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}]},"typeAsHTML":"{source: Node, weight: ?string, cutoff: ?number}","description":"\n- source: Starting node for path\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned."}],"description":"Compute shortest path between source and all other reachable nodes for a\nweighted graph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.singleSourceDijkstraPath(G, {source: 0});\npath.get(4);\n// [0, 1, 2, 3, 4]\n```\n\n### Notes\n\nEdge weight attributes must be numerical. Distances are calculated as sums\nof weighted edges traversed.","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"Map of shortest paths keyed by target"},"see":"singleSourceDijkstra","async":false,"asyncName":"genSingleSourceDijkstraPath","categories":["algorithms","shortestPaths","weighted"]},"genSingleSourceDijkstraPath":{"name":"genSingleSourceDijkstraPath","aliases":["genSingleSourceDijkstraPath","algorithms.genSingleSourceDijkstraPath","algorithms.shortestPaths.genSingleSourceDijkstraPath","algorithms.shortestPaths.weighted.genSingleSourceDijkstraPath","algorithms.weighted.genSingleSourceDijkstraPath","shortestPaths.genSingleSourceDijkstraPath","shortestPaths.weighted.genSingleSourceDijkstraPath","weighted.genSingleSourceDijkstraPath"],"syncName":"singleSourceDijkstraPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}]},"typeAsHTML":"{source: Node, weight: ?string, cutoff: ?number}","description":"\n- source: Starting node for path\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned."}],"categories":["algorithms","shortestPaths","weighted"]},"singleSourceDijkstraPathLength":{"name":"singleSourceDijkstraPathLength","aliases":["singleSourceDijkstraPathLength","algorithms.singleSourceDijkstraPathLength","algorithms.shortestPaths.singleSourceDijkstraPathLength","algorithms.shortestPaths.weighted.singleSourceDijkstraPathLength","algorithms.weighted.singleSourceDijkstraPathLength","shortestPaths.singleSourceDijkstraPathLength","shortestPaths.weighted.singleSourceDijkstraPathLength","weighted.singleSourceDijkstraPathLength"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}]},"typeAsHTML":"{source: Node, weight: ?string, cutoff: ?number}","description":"\n- source: Starting node for path\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned."}],"description":"Compute the shortest path length between source and all other reachable\nnodes for a weighted graph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\nvar length = jsnx.singleSourceDijkstraPathLength(G, {source: 0});\nlength.get(4);\n// 4\nlength\n// Map {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n```\n\n### Notes\n\nEdge weight attributes must be numerical. Distances are calculated as sums\nof weighted edges traversed.","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"Map of shortest paths keyed by target"},"see":"singleSourceDijkstra","async":false,"asyncName":"genSingleSourceDijkstraPathLength","categories":["algorithms","shortestPaths","weighted"]},"genSingleSourceDijkstraPathLength":{"name":"genSingleSourceDijkstraPathLength","aliases":["genSingleSourceDijkstraPathLength","algorithms.genSingleSourceDijkstraPathLength","algorithms.shortestPaths.genSingleSourceDijkstraPathLength","algorithms.shortestPaths.weighted.genSingleSourceDijkstraPathLength","algorithms.weighted.genSingleSourceDijkstraPathLength","shortestPaths.genSingleSourceDijkstraPathLength","shortestPaths.weighted.genSingleSourceDijkstraPathLength","weighted.genSingleSourceDijkstraPathLength"],"syncName":"singleSourceDijkstraPathLength","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}]},"typeAsHTML":"{source: Node, weight: ?string, cutoff: ?number}","description":"\n- source: Starting node for path\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned."}],"categories":["algorithms","shortestPaths","weighted"]},"singleSourceDijkstra":{"name":"singleSourceDijkstra","aliases":["singleSourceDijkstra","algorithms.singleSourceDijkstra","algorithms.shortestPaths.singleSourceDijkstra","algorithms.shortestPaths.weighted.singleSourceDijkstra","algorithms.weighted.singleSourceDijkstra","shortestPaths.singleSourceDijkstra","shortestPaths.weighted.singleSourceDijkstra","weighted.singleSourceDijkstra"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{source: Node, target: ?Node, cutoff: ?number, weight: ?string}","description":"\n- source: Starting node for path\n- target: Ending node in the path (optional)\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned."}],"description":"Compute shortest paths and lengths in a weighted graph G.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\nvar [lengths, paths] = jsnx.singleSourceDijkstra(G, {source: 0});\nlengths.get(4);\n// 4\nlengths\n// Map {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\npaths.get(4);\n// [0, 1, 2, 3, 4]\n```\n\n### Notes\n\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThis algorithm is not guaranteed to work if edge weights are negative or are\nfloating point numbers (overflows and roundoff errors can cause problems).","returns":{"name":"","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"Array.&lt;Map>","description":"Returns a tuple of two Maps keyed by node. The first Map stores distances\n from the source. The second one stores the path from the source to that\n node."},"see":["singleSourceDijkstraPath","singleSourceDijkstraPathLength"],"async":false,"asyncName":"genSingleSourceDijkstra","categories":["algorithms","shortestPaths","weighted"]},"genSingleSourceDijkstra":{"name":"genSingleSourceDijkstra","aliases":["genSingleSourceDijkstra","algorithms.genSingleSourceDijkstra","algorithms.shortestPaths.genSingleSourceDijkstra","algorithms.shortestPaths.weighted.genSingleSourceDijkstra","algorithms.weighted.genSingleSourceDijkstra","shortestPaths.genSingleSourceDijkstra","shortestPaths.weighted.genSingleSourceDijkstra","weighted.genSingleSourceDijkstra"],"syncName":"singleSourceDijkstra","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"parameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"source"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}}]},"typeAsHTML":"{source: Node, target: ?Node, cutoff: ?number, weight: ?string}","description":"\n- source: Starting node for path\n- target: Ending node in the path (optional)\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned."}],"categories":["algorithms","shortestPaths","weighted"]},"allPairsDijkstraPathLength":{"name":"allPairsDijkstraPathLength","aliases":["allPairsDijkstraPathLength","algorithms.allPairsDijkstraPathLength","algorithms.shortestPaths.allPairsDijkstraPathLength","algorithms.shortestPaths.weighted.allPairsDijkstraPathLength","algorithms.weighted.allPairsDijkstraPathLength","shortestPaths.allPairsDijkstraPathLength","shortestPaths.weighted.allPairsDijkstraPathLength","weighted.allPairsDijkstraPathLength"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}],"optional":true},"typeAsHTML":"{weight: ?string, cutoff: ?number}=","description":"\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned.","defaultValue":"{}"}],"description":"Compute shortest path lengths between all nodes in a weighted graph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.allPairsDijkstraPath(G);\npath.get(1).get(4);\n// 3\npath.get(1);\n// Map {0: 1, 1: 0, 2: 1, 3: 2, 4: 3}\n```\n\n### Notes\n\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe Map returned only has keys for reachable node pairs.","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"A Map of Maps of shortest path lengths"},"see":[],"async":false,"asyncName":"genAllPairsDijkstraPathLength","categories":["algorithms","shortestPaths","weighted"]},"genAllPairsDijkstraPathLength":{"name":"genAllPairsDijkstraPathLength","aliases":["genAllPairsDijkstraPathLength","algorithms.genAllPairsDijkstraPathLength","algorithms.shortestPaths.genAllPairsDijkstraPathLength","algorithms.shortestPaths.weighted.genAllPairsDijkstraPathLength","algorithms.weighted.genAllPairsDijkstraPathLength","shortestPaths.genAllPairsDijkstraPathLength","shortestPaths.weighted.genAllPairsDijkstraPathLength","weighted.genAllPairsDijkstraPathLength"],"syncName":"allPairsDijkstraPathLength","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}],"optional":true},"typeAsHTML":"{weight: ?string, cutoff: ?number}=","description":"\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned.","defaultValue":"{}"}],"categories":["algorithms","shortestPaths","weighted"]},"allPairsDijkstraPath":{"name":"allPairsDijkstraPath","aliases":["allPairsDijkstraPath","algorithms.allPairsDijkstraPath","algorithms.shortestPaths.allPairsDijkstraPath","algorithms.shortestPaths.weighted.allPairsDijkstraPath","algorithms.weighted.allPairsDijkstraPath","shortestPaths.allPairsDijkstraPath","shortestPaths.weighted.allPairsDijkstraPath","weighted.allPairsDijkstraPath"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}],"optional":true},"typeAsHTML":"{weight: ?string, cutoff: ?number}=","description":"\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned.","defaultValue":"{}"}],"description":"Compute shortest paths between all nodes in a weighted graph.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.allPairsDijkstraPath(G);\npath.get(0).get(4);\n// [0, 1, 2, 3, 4]\n```\n\n### Notes\n\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.","returns":{"name":"","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"A Map of Maps of shortest paths."},"see":[],"async":false,"asyncName":"genAllPairsDijkstraPath","categories":["algorithms","shortestPaths","weighted"]},"genAllPairsDijkstraPath":{"name":"genAllPairsDijkstraPath","aliases":["genAllPairsDijkstraPath","algorithms.genAllPairsDijkstraPath","algorithms.shortestPaths.genAllPairsDijkstraPath","algorithms.shortestPaths.weighted.genAllPairsDijkstraPath","algorithms.weighted.genAllPairsDijkstraPath","shortestPaths.genAllPairsDijkstraPath","shortestPaths.weighted.genAllPairsDijkstraPath","weighted.genAllPairsDijkstraPath"],"syncName":"allPairsDijkstraPath","async":true,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optParameters","type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"weight"},"value":{"type":"NameExpression","name":"string","nullable":true}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number","nullable":true}}],"optional":true},"typeAsHTML":"{weight: ?string, cutoff: ?number}=","description":"\n- weight: Edge data key corresponding to the edge weight\n- cutoff: Depth to stop the search. Only paths of length <= cutoff are\n  returned.","defaultValue":"{}"}],"categories":["algorithms","shortestPaths","weighted"]},"Graph":{"name":"Graph","aliases":["Graph","classes.Graph"],"isClass":true,"description":"Base class for undirected graphs.\n\nA Graph stores nodes and edges with optional data, or attributes.\n\nGraphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not.\n\nNodes can be strings, numbers or any object with a custom `toString` method.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\n### Examples\n\nCreate an empty graph (a \"null graph\") with no nodes and no edges.\n\n```\nvar G = new jsnx.Graph();\n```\n\nG can be grown in several ways.\n\n#### Nodes\n\nAdd one node at a time:\n\n```\nG.addNode(1);\n```\n\nAdd the nodes from any iterable:\n\n```\nG.addNodesFrom([2, 3]);\nG.addNodesFrom(new Set('foo', 'bar'));\nvar H = jsnx.completeGraph(10);\nG.addNodesFrom(H);\n```\n\nIn addition to strings, numbers and arrays, any object that implements a\ncustom `toString` method can be used as node.\n\n#### Edges\n\n`G` can also be grown by adding edges.\n\nAdd one edge,\n\n```\nG.addEdge(1, 2);\n```\n\na list of edges,\n\n```\nG.addEdgesFrom([[1,2], [1,3]]);\n```\n\nor a collection of edges,\n\n```\nG.addEdgesFrom(H.edges);\n```\n\nIf some edges connect nodes not yet in the graph, the nodes are added\nautomatically. There are no errors when adding nodes or edges that already\nexist.\n\n#### Attributes\n\nEach graph, node and edge can hold key/value attribute pairs in an associated\nattribute object (keys must be strings or numbers).\nBy default these are empty, but can added or changed using `addEdge`,\n`addNode`.\n\n```\nvar G = new jsnx.Graph(null, {day: 'Friday'});\nG.graph\n// {day: 'Friday'}\n```\n\nAdd node attributes using `addNode()` or `addNodesFrom()`:\n\n```\nG.addNode(1, {time: '5pm'});\nG.addNodesFrom([2, [3, {time: '3pm'}]], {time: '2pm'});\nG.nodes(true);\n// [[1, {time: '5pm'}], [2, {time: '2pm'}], [3, {time: '3pm'}]]\n```\n\nAdd edge attributes using `addEdge()`, or `addEdgesFrom()`:\n\n```\nG.addEdge(1, w, {weight: 4.7});\nG.addEdgesFrom([[3,4], [4,5]], {color: 'red'});\n```","extends":null,"methods":[{"name":"toString","computed":false,"params":[],"description":"Return the graph name","returns":{"name":"","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","description":"Graph name."},"see":[],"async":false},{"name":"get","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"A node in the graph."}],"description":"Return a Map of neighbors of node n.","returns":{"name":"","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","description":"The adjacency dictionary for nodes connected to n."},"see":[],"async":false},{"name":"addNode","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"opt_attr_dict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Dictionary of node attributes.\n    Key/value pairs will update existing data associated with the node.","defaultValue":"{}"}],"description":"Add a single node n and update node attributes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addNode(1);\nG.addNode('Hello');\nG.numberOfNodes();\n2\n```","see":"#addNodesFrom","async":false},{"name":"addNodesFrom","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nAn iterable of nodes\nOR\nAn iterable of (node, object) tuples."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple\n    take precedence over attributes specified generally.","defaultValue":"{}"}],"description":"Add multiple nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or DiGraph, MultiGraph, MultiDiGraph\nG.addNodesFrom([1,2,3]);\nG.nodes();\n// [1,2,3]\n```\n\nUse the second argument to update specific node attributes for every node.\n\n```\nG.addNodesFrom([1,2], {size: 10});\nG.addNodesFrom([2,3], {weight: 0.4});\n```\n\nUse `(node, object)` tuples to update attributes for specific nodes.\n\n```\nG.addNodesFrom([[1, {size: 11}], [2, {color: 'blue'}]]);\nG.node.get(1).size\n// 11\nvar H = new jsnx.Graph();\nH.addNodesFrom(G.nodes(true));\nH.node.get(1).size\n// 11\n```","see":"#addNode","async":false},{"name":"removeNode","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"A node in the graph"}],"description":"Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a non-existent node will raise an exception.\n\n### Example\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.edges();\n// [[0,1], [1,2]]\nG.removeNode(1);\nG.edges();\n// []\n```","see":"#removeNodesFrom","async":false},{"name":"removeNodesFrom","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A container of nodes.\n   If a node in the container is not in the graph it is silently ignored."}],"description":"Remove multiple nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nvar e = G.nodes(); // [0,1,2]\nG.removeNodesFrom(e);\nG.nodes();\n// []\n```","see":"#removeNode","async":false},{"name":"nodesIter","computed":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"If false the iterator returns\n nodes. If true return a two-tuple of node and node data dictionary.","defaultValue":"false"}],"description":"Return an iterator over the nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nvar data = [];\nArray.from(G.nodesIter(true)).map(([node, data]) => data);\n// [{}, {}, {}]\n```\n\n### Notes\n\nIf the node is not required, it is simpler and equivalent to use `G`, e.g.\n`Array.from(G)` or `for (var node of G)`.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"of nodes If data=true the iterator gives\n         two-tuples containing (node, node data, dictionary)."},"see":[],"async":false},{"name":"nodes","computed":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"If false the iterator returns\n nodes. If true return a two-tuple of node and node data dictionary.","defaultValue":"false"}],"description":"Return a list of the nodes in the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.nodes();\n// [0,1,2]\nG.addNode(1, {time: '5pm'});\nG.nodes(true);\n// [[0,{}], [1,{time: '5pm'}], [2,{}]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"of nodes If data=true a list of two-tuples containing\n         (node, node data object)."},"see":[],"async":false},{"name":"numberOfNodes","computed":false,"params":[],"description":"Return the number of nodes in the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.numberOfNodes();\n// 3\n```","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes in the graph."},"see":"#order","async":false},{"name":"order","computed":false,"params":[],"description":"Return the number of nodes in the graph.","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes in the graph."},"see":"#numberOfNodes","async":false},{"name":"hasNode","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node."}],"description":"Return true if the graph contains the node n.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.hasNode(0);\n// true\n```","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"},"see":[],"async":false},{"name":"addEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Object of edge attributes.\n    Key/value pairs will update existing data associated with the edge."}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by providing\na object with key/value pairs as third argument.\n\n\n### Examples\n\nThe following all add the edge `(1,2)` to graph `G`:\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdge(1,2);\nG.addEdgesFrom([[1,2]]);\n```\n\nAssociate data to edges using an object:\n\n```\nG.addEdge(1, 2, {weight: 3});\nG.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});\n```\n\n### Notes\n\nAdding an edge that already exists updates the edge data.\n\nMany algorithms designed for weighted graphs use as the edge weight a\nnumerical value assigned to an attribute which by default is 'weight'.","see":"#addEdgesFrom","async":false},{"name":"addEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"container of edges\n    Each edge given in the container will be added to the\n    graph. The edges must be given as as 2-tuples (u,v) or\n    3-tuples (u,v,d) where d is a dictionary containing edge data."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Object of edge attributes.\n    Dictionary of edge attributes.  Key/value pairs will\n    update existing data associated with each edge."}],"description":"Add all the edges in `ebunch`.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdgesFrom([[0,1], [1,2]]); // using a list of edges\n```\n\nAssociate data to edges\n\n```\nG.addEdgesFrom([[1,2], [2,3]], {weight: 3});\nG.addEdgesFrom([[3,4], [1,4]], {label: 'WN2898'});\n```\n\n### Notes\n\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.","see":["#add_edge","#addWeightedEdgesFrom"],"async":false},{"name":"addWeightedEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"container of edges\n   Each edge given in the list or container will be added\n   to the graph. The edges must be given as 3-tuples (u,v,w)\n   where w is a number."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"(default 'weight')\n    The attribute name for the edge weights to be added."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Edge attributes to add/update for all edges."}],"description":"Add all the edges in `ebunch` as weighted edges with specified weights.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addWeightedEdgesFrom([[0,1,3.0], [1,2,7.5]]);\n```\n\n### Note\n\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data.  For MultiGraph/MultiDiGraph, duplicate edges\nare stored.","see":["#addEdge","#addEdgesFrom"],"async":false},{"name":"removeEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Remove the edge between u and v.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.removeEdge(0,1);\n```","see":"#removeEdgesFrom","async":false},{"name":"removeEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"Iterable of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n      - 2-tuples (u,v) edge between u and v.\n      - 3-tuples (u,v,k) where k is ignored."}],"description":"Remove all edges specified in `ebunch`.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nvar ebunch = [[1,2], [2,3]];\nG.removeEdgesFrom(ebunch);\n```\n\n### Notes\n\nWill fail silently if an edge in `ebunch` is not in the graph.","see":[],"async":false},{"name":"hasEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node."},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node."}],"description":"Return True if the edge (u,v) is in the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.hasEdge(0, 1);\n// true\nvar edge = [0, 1];\nG.hasEdge.apply(G, edge);\n// true\n```","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if edge is in the graph, False otherwise."},"see":[],"async":false},{"name":"neighbors","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node","nullable":false},"typeAsHTML":"!Node","description":"A node in the graph."}],"description":"Return a list of the nodes connected to the node n.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.neighbors(0);\n// [1]\n```\n\n### Notes\n\nIt can be more convenient to access the adjacency map as `G.get(n)`:\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdge('a', 'b', {weight: 7});\nG.get('a');\n// Map {'b': {weight: 7}}\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"A list of nodes that are adjacent to n."},"see":[],"async":false},{"name":"neighborsIter","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node","nullable":false},"typeAsHTML":"!Node","description":"A node in the graph."}],"description":"Return an iterator over all neighbors of node n.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nArray.from(G.neighborsIter(0));\n// [1]\n```\n\nYou could also iterate over the adjacency map instead:\n\n```\nArray.from(G.get(0).keys());\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"A list of nodes that are adjacent to n."},"see":[],"async":false},{"name":"edges","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true,"nullable":true},"typeAsHTML":"?(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"Return two tuples (u,v) (False)\n    or three-tuples (u,v,data) (True).","defaultValue":"false"}],"description":"Return a list of edges.\n\nEdges are returned as tuples with optional data\nin the order (node, neighbor, data).\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.addEdge(2, 3, {weight: 5});\nG.edges();\n// [[0,1], [1,2], [2,3]]\nG.edges(true);\n// [[0,1,{}], [1,2,{}], [2,3, {weight: 5}]\nG.edges([0,3]);\n// [[0,1], [3,2]]\nG.edges(0);\n// [[0,1]]\n```\n\n### Note\n\nNodes in `nbunch` that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"list of edge tuples\n    Edges that are adjacent to any node in nbunch, or a list\n    of all edges if nbunch is not specified."},"see":[],"async":false},{"name":"edgesIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true,"nullable":true},"typeAsHTML":"?(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"Return two tuples (u,v) (False)\n    or three-tuples (u,v,data) (True).","defaultValue":"false"}],"description":"Return an iterator over the edges.\n\nEdges are returned as tuples with optional data\nin the order (node, neighbor, data).\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.addEdge(2, 3, {weight: 5});\nArray.from(G.edgesIter());\n// [[0,1], [1,2], [2,3]]\nArray.from(G.edgesIter(true));\n// [[0,1,{}], [1,2,{}], [2,3, {weight: 5}]\nArray.from(G.edgesIter([0,3]));\n// [[0,1], [3,2]]\nArray.from(G.edgesIter(0));\n// [[0,1]]\n```\n\n### Note\n\nNodes in `nbunch` that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"iterater if `(u,v)` or `(u,v,d)` edge tuples"},"see":[],"async":false},{"name":"getEdgeData","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node."},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node."},{"name":"optDefault","type":{"type":"AllLiteral"},"typeAsHTML":"*","description":"\nValue to return if the edge (u,v) is not found.","defaultValue":"null"}],"description":"Return the attribute object associated with edge (u,v).\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.getEdgeData(0,1);\n// {}\n```\n\nIf the edge exists, it may be simpler to access `G.get(0).get(1)`.","returns":{"name":"","type":{"type":"AllLiteral"},"typeAsHTML":"*","description":"The edge attribute object."},"see":[],"async":false},{"name":"adjacencyList","computed":false,"params":[],"description":"Return an adjacency list representation of the graph.\n\nThe output adjacency list is in the order of G.nodes().\nFor directed graphs, only outgoing adjacencies are included.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.adjacencyList();\n// [[1], [0,2], [1,3], [2]]\n```","returns":{"name":"","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!Array.&lt;Array>","description":"The adjacency structure of the graph as a\n    list of lists."},"see":[],"async":false},{"name":"adjacencyIter","computed":false,"params":[],"description":"Return an iterator of (node, adjacency map) tuples for all nodes.\n\nFor directed graphs, only outgoing adjacencies are included.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nArray.from(G.adjacencyIter());\n// [\n//   [0, Map {1: {}}],\n//   [1, Map {0: {}, 2: {}}],\n//   [2, Map {1: {}, 3: {}}],\n//   [3, Map {2: {}]]\n// ]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"An array of (node, adjacency map) tuples\n    for all nodes in the graph."},"see":[],"async":false},{"name":"degree","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"(default=all nodes)\n    An iterable of nodes.  The iterable will be iterated\n    through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If null or not defined, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return the degree of a node or nodes.\n\nThe node degree is the number of edges adjacent to that node.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();  // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3])\nG.degree(0)\n// 1\nG.degree([0,1])\n// Map {0: 1, 1: 2}\nArray.from(G.degree([0,1]).values())\n// [1, 2]\n```","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}],"nullable":false},"typeAsHTML":"!(number|Map)","description":"A dictionary with nodes as keys and\n    degree as values or a number if a single node is specified."},"see":[],"async":false},{"name":"degreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"(default=all nodes)\n     A container of nodes.  The container will be iterated\n     through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If null or not defined, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return an array for (node, degree).\n\nThe node degree is the number of edges adjacent to that node.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();  // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3])\nArray.from(G.degreeIter(0));\n// [[0, 1]]\nArray.from(G.degreeIter([0,1]));\n// [[0, 1], [1, 2]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"of two-tuples of (node, degree)."},"see":[],"async":false},{"name":"clear","computed":false,"params":[],"description":"Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.clear();\nG.nodes();\n// []\nG.edges();\n// []\n```","see":[],"async":false},{"name":"copy","computed":false,"params":[],"description":"Return a copy of the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nvar H = G.copy();\n```\n\n### Notes\n\nThis makes a complete copy of the graph including all of the\nnode or edge attributes.","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},"see":[],"async":false},{"name":"isMultigraph","computed":false,"params":[],"description":"Return True if graph is a multigraph, False otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is a multigraph, False otherwise."},"see":[],"async":false},{"name":"isDirected","computed":false,"params":[],"description":"Return True if graph is directed, False otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is directed, False otherwise."},"see":[],"async":false},{"name":"toDirected","computed":false,"params":[],"description":"Return a directed representation of the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or MultiGraph, etc\nG.addPath([0,1]);\nvar H = G.toDirected();\nH.edges();\n// [[0,1], [1,0]]\n```\n\nIf already directed, return a (deep) copy\n\n```\nvar G = new jsnx.DiGraph(); // or MultiDiGraph, etc\nG.addPath([0,1]);\nvar H = G.toDirected();\nH.edges();\n// [[0,1]]\n```\n\n### Notes\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var H = new jsnx.DiGraph(G)` which\nreturns a shallow copy of the data.","returns":{"name":"","type":{"type":"NameExpression","name":"DiGraph","nullable":false},"typeAsHTML":"!DiGraph","description":"A directed graph with the same name, same nodes, and with\n each edge (u,v,data) replaced by two directed edges\n (u,v,data) and (v,u,data)."},"see":[],"async":false},{"name":"toUndirected","computed":false,"params":[],"description":"Return an undirected copy of the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or MultiGraph, etc\nG.addPath([0,1]);\nvar H = G.toDirected();\nG.edges();\n// [[0,1], [1,0]]\nvar G2 = H.toUndirected();\nG2.edges();\n// [[0,1]]\n```\n\n### Notes\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var H = new jsnx.Graph(G);` which\nreturns a shallow copy of the data.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","description":"A deepcopy of the graph."},"see":[],"async":false},{"name":"subgraph","computed":false,"params":[{"name":"nbunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nAn iterable of nodes which will be iterated through once."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nThe induced subgraph of the graph contains the nodes in nbunch\nand the edges between those nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nvar H = G.subgraph([0,1,2]);\nH.edges();\n// [[0,1], [1,2]]\n```\n\n### Notes\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`new jsnx.Graph(G.subgraph(nbunch))`.\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\n\n```\nG.removeNodesFrom(G.nodes().filter(function(n) {\n     return nbunch.indexOf(n) > -1;\n}))\n```","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false},{"name":"nodesWithSelfloops","computed":false,"params":[],"description":"Return a list of nodes with self loops.\n\nA node with a self loop has an edge with both ends adjacent\nto that node.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdge(1, 1)\nG.addEdge(1, 2)\nG.nodesWithSelfloops()\n// [1]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"A list of nodes with self loops."},"see":[],"async":false},{"name":"selfloopEdges","computed":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"\nReturn selfloop edges as two tuples (u,v) (data=False)\nor three-tuples (u,v,data) (data=True).","defaultValue":"false"}],"description":"Return a list of selfloop edges.\n\nA selfloop edge has the same node at both ends.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdge(1,1)\nG.addEdge(1,2)\nG.selfloopEdges()\n// [(1, 1)]\nG.selfloop_edges(true)\n// [(1, 1, {})]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"A list of all selfloop edges."},"see":[],"async":false},{"name":"numberOfSelfloops","computed":false,"params":[],"description":"Return the number of selfloop edges.\n\nA selfloop edge has the same node at both ends.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nG.number_of_selfloops()\n// 1\n```","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of selfloops."},"see":[],"async":false},{"name":"size","computed":false,"params":[{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"The edge attribute that holds the numerical\n    value used as a weight.  If not defined, then each edge has weight 1."}],"description":"Return the number of edges.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3])\nG.size()\n// 3\n\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdge('a',' b', {weight: 2});\nG.addEdge('b', 'c', {weight: 4});\nG.size()\n// 2\nG.size('weight');\n// 6.0\n```","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of edges or sum of edge weights in the graph."},"see":[],"async":false},{"name":"numberOfEdges","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node","optional":true,"nullable":false},"typeAsHTML":"!Node=","description":"node."},{"name":"v","type":{"type":"NameExpression","name":"Node","optional":true,"nullable":false},"typeAsHTML":"!Node=","description":"node\n     If u and v are both specified, return the number of edges between\n     u and v. Otherwise return the total number of all edges."}],"description":"Return the number of edges between two nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.numberOfEdges();\n// 3\nG.number_of_edges(0,1);\n// 1\n```","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of edges in the graph.\n    If nodes u and v are specified return the number of edges between\n    those nodes."},"see":[],"async":false},{"name":"addStar","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A container of nodes."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Attributes to add to every edge in the star."}],"description":"Add a star.\n\n### Examples\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addStar([0,1,2,3]);\nG.addStar([10,11,12], {weight: 2});\n```\n\nThe first node in nodes is the middle of the star.  It is connected\nto all other nodes.","see":[],"async":false},{"name":"addPath","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A container of nodes.\n    A path will be constructed from the nodes (in order)\n    and added to the graph."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Attributes to add to every edge in path."}],"description":"Add a path.\n\n### Examples\n\n```\nvar G= new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.addPath([10,11,12], {weight: 7});\n```","see":[],"async":false},{"name":"addCycle","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A container of nodes.\n    A cycle will be constructed from the nodes (in order)\n    and added to the graph."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Attributes to add to every edge in cycle."}],"description":"Add a cycle.\n\n### Examples\n\n```\nvar G= new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addCycle([0,1,2,3]);\nG.addCycle([10,11,12], {weight: 7});\n```","see":[],"async":false},{"name":"nbunchIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"(default=all nodes)\n    A container of nodes.  The container will be iterated\n    through once."}],"description":"Return an iterator of nodes contained in `nbunch` that are\nalso in the graph.\n\nThe nodes in `nbunch` are checked for membership in the graph\nand if not are silently ignored.\n\n### Notes\n\nWhen `nbunch` is an iterator, the returned iterator yields values\ndirectly from `nbunch`, becoming exhausted when `nbunch` is exhausted.\n\nTo test whether `nbunch` is a single node, one can use\n`if (this.hasNode(nbunch))`, even after processing with this routine.\n\nIf `nbunch` is not a node or a (possibly empty) sequence/iterator\nor not defined, an Error is raised.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"An iterator over nodes in nbunch\n    that are also in the graph.\n    If nbunch is null or not defined, iterate over all nodes in the graph."},"see":[],"async":false},{"name":"Symbol.iterator","computed":true,"params":[],"description":"A graph is an iterable over its nodes.\n\n### Example\n\n```\nvar G = new jsnx.Graph();   // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addNodesFrom([0,1,2,3]);\nfor (var node of G) {\n  console.log(node);\n}\n```","returns":{"type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator"},"see":[],"async":false}],"properties":[{"name":"name","computed":false,"params":[],"description":"Gets or sets the name of the graph.","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"UndefinedLiteral"}]},"typeAsHTML":"(string|undefined)","description":"Graph name if no parameter was passed."},"see":[],"async":false,"readonly":false}],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"params":[],"description":"Holds the graph type (class) name for information.","see":[],"async":false,"readonly":true}],"constructor":{"name":"Graph","computed":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"Data to initialize graph.  If `data` is not\n  provided, an empty graph is created. The data can be an edge list, or\n  any JSNetworkX graph object."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"(default=no attributes)\n  Attributes to add to graph as key=value pairs."}],"description":"","see":[],"async":false},"categories":["classes"]},"DiGraph":{"name":"DiGraph","aliases":["DiGraph","classes.DiGraph"],"isClass":true,"description":"Base class for directed graphs.\n\nA DiGraph stores nodes and edges with optional data, or attributes.\n\nDiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not.\n\nNodes can be strings, numbers or any object with a custom `toString` method.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\n### Examples\n\nCreate an empty graph (a \"null graph\") with no nodes and no edges.\n\n```\nvar G = new jsnx.DiGraph();\n```\n\nG can be grown in several ways.\n\n#### Nodes\n\nAdd one node at a time:\n\n```\nG.addNode(1);\n```\n\nAdd the nodes from any iterable:\n\n```\nG.addNodesFrom([2, 3]);\nG.addNodesFrom(new Set('foo', 'bar'));\nvar H = jsnx.completeGraph(10);\nG.addNodesFrom(H);\n```\n\nIn addition to strings, numbers and arrays, any object that implements a\ncustom `toString` method can be used as node.\n\n#### Edges\n\n`G` can also be grown by adding edges.\n\nAdd one edge,\n\n```\nG.addEdge(1, 2);\n```\n\na list of edges,\n\n```\nG.addEdgesFrom([[1,2], [1,3]]);\n```\n\nor a collection of edges,\n\n```\nG.addEdgesFrom(H.edges);\n```\n\nIf some edges connect nodes not yet in the graph, the nodes are added\nautomatically. There are no errors when adding nodes or edges that already\nexist.\n\n#### Attributes\n\nEach graph, node and edge can hold key/value attribute pairs in an associated\nattribute object (keys must be strings or numbers).\nBy default these are empty, but can added or changed using `addEdge`,\n`addNode`.\n\n```\nvar G = new jsnx.DiGraph(null, {day: 'Friday'});\nG.graph\n// {day: 'Friday'}\n```\n\nAdd node attributes using `addNode()` or `addNodesFrom()`:\n\n```\nG.addNode(1, {time: '5pm'});\nG.addNodesFrom([2, [3, {time: '3pm'}]], {time: '2pm'});\nG.nodes(true);\n// [[1, {time: '5pm'}], [2, {time: '2pm'}], [3, {time: '3pm'}]]\n```\n\nAdd edge attributes using `addEdge()`, or `addEdgesFrom()`:\n\n```\nG.addEdge(1, w, {weight: 4.7});\nG.addEdgesFrom([[3,4], [4,5]], {color: 'red'});\n```","extends":"Graph","methods":[{"name":"addNode","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"opt_attr_dict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Dictionary of node attributes.\n    Key/value pairs will update existing data associated with the node.","defaultValue":"{}"}],"description":"Add a single node n and update node attributes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addNode(1);\nG.addNode('Hello');\nG.numberOfNodes();\n2\n```","see":"#addNodesFrom","async":false},{"name":"addNodesFrom","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nAn iterable of nodes\nOR\nAn iterable of (node, object) tuples."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple\n    take precedence over attributes specified generally.","defaultValue":"{}"}],"description":"Add multiple nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or DiGraph, MultiGraph, MultiDiGraph\nG.addNodesFrom([1,2,3]);\nG.nodes();\n// [1,2,3]\n```\n\nUse the second argument to update specific node attributes for every node.\n\n```\nG.addNodesFrom([1,2], {size: 10});\nG.addNodesFrom([2,3], {weight: 0.4});\n```\n\nUse `(node, object)` tuples to update attributes for specific nodes.\n\n```\nG.addNodesFrom([[1, {size: 11}], [2, {color: 'blue'}]]);\nG.node.get(1).size\n// 11\nvar H = new jsnx.Graph();\nH.addNodesFrom(G.nodes(true));\nH.node.get(1).size\n// 11\n```","see":"#addNode","async":false},{"name":"removeNode","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"A node in the graph"}],"description":"Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a non-existent node will raise an exception.\n\n### Example\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nG.edges();\n// [[0,1], [1,2]]\nG.removeNode(1);\nG.edges();\n// []\n```","see":"#removeNodesFrom","async":false},{"name":"removeNodesFrom","computed":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A container of nodes.\n   If a node in the container is not in the graph it is silently ignored."}],"description":"Remove multiple nodes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2]);\nvar e = G.nodes(); // [0,1,2]\nG.removeNodesFrom(e);\nG.nodes();\n// []\n```","see":"#removeNode","async":false},{"name":"addEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Object of edge attributes.\n    Key/value pairs will update existing data associated with the edge.","defaultValue":"{}"}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by providing\na object with key/value pairs as third argument.\n\n\n### Examples\n\nThe following all add the edge `(1,2)` to graph `G`:\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdge(1,2);\nG.addEdgesFrom([[1,2]]);\n```\n\nAssociate data to edges using an object:\n\n```\nG.addEdge(1, 2, {weight: 3});\nG.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});\n```\n\n### Notes\n\nAdding an edge that already exists updates the edge data.\n\nMany algorithms designed for weighted graphs use as the edge weight a\nnumerical value assigned to an attribute which by default is 'weight'.","see":"#addEdgesFrom","async":false},{"name":"addEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"container of edges\n    Each edge given in the container will be added to the\n    graph. The edges must be given as as 2-tuples (u,v) or\n    3-tuples (u,v,d) where d is a dictionary containing edge data."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Object of edge attributes.\n    Dictionary of edge attributes.  Key/value pairs will\n    update existing data associated with each edge.","defaultValue":"{}"}],"description":"Add all the edges in `ebunch`.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addEdgesFrom([[0,1], [1,2]]); // using a list of edges\n```\n\nAssociate data to edges\n\n```\nG.addEdgesFrom([[1,2], [2,3]], {weight: 3});\nG.addEdgesFrom([[3,4], [1,4]], {label: 'WN2898'});\n```\n\n### Notes\n\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.","see":["#add_edge","#addWeightedEdgesFrom"],"async":false},{"name":"removeEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Remove the edge between u and v.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.removeEdge(0,1);\n```","see":"#removeEdgesFrom","async":false},{"name":"removeEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"Iterable of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n      - 2-tuples (u,v) edge between u and v.\n      - 3-tuples (u,v,k) where k is ignored."}],"description":"Remove all edges specified in `ebunch`.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nvar ebunch = [[1,2], [2,3]];\nG.removeEdgesFrom(ebunch);\n```\n\n### Notes\n\nWill fail silently if an edge in `ebunch` is not in the graph.","see":[],"async":false},{"name":"hasSuccessor","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return True if node u has successor v.\n\nThis is true if graph has the edge u->v.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if node u has successor v"},"see":[],"async":false},{"name":"hasPredecessor","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return True if node u has predecessor v.\n\nThis is true if graph has the edge u<-v.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if node u has predecessor v"},"see":[],"async":false},{"name":"successorsIter","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return an iterator over successor nodes of n.\n\n`neighborsIter()` and `successorsIter()` are the same.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"Iterator over successor nodes of n"},"see":[],"async":false},{"name":"predecessorsIter","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return an iterator over predecessor nodes of n.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"Iterator over predecessor nodes of n"},"see":[],"async":false},{"name":"successors","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return a list of successor nodes of n.\n\n`neighbors()` and `successors()` are the same.","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"List of successor nodes of n"},"see":[],"async":false},{"name":"predecessors","computed":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return list of predecessor nodes of n.","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"List of predecessor nodes of n"},"see":[],"async":false},{"name":"neighbors","computed":false,"params":[{"name":"n"}],"description":"","see":[],"aliasFor":"successors","async":false},{"name":"neighborsIter","computed":false,"params":[{"name":"n"}],"description":"","see":[],"aliasFor":"successorsIter","async":false},{"name":"edgesIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"A container of nodes.\n     The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"\nIf True, return edge attribute dict in 3-tuple (u,v,data).","defaultValue":"false"}],"description":"Return an iterator over the edges.\n\nEdges are returned as tuples with optional data in the order\n`(node, neighbor, data)`.\n\n### Examples\n\n```\nvar G = new jsnx.DiGraph() // or MultiDiGraph, etc\nG.addPath([0,1,2]);;\nG.addEdge(2, 3, {weight: 5});\nArray.from(G.edgesIter());\n// [[0,1], [1,2], [2,3]]\nArray.from(G.edgeIter(true)); // default data is {}\n// [[0,1,{}], [1,2,{}], [2,3,{weight: 5}]]\nArray.from(G.edgesIter([0,2]));\n// [[0,1], [2,3]]\nArray.from(G.edgesIter(0));\n// [[0,1]]\n```\n\n\n### Notes\n\nNodes in `nbunch` that are not in the graph will be (quietly) ignored.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"An iterator of (u,v) or (u,v,d) tuples of edges."},"see":"#edges","async":false},{"name":"outEdgesIter","computed":false,"params":[{"name":"optNbunch"},{"name":"optData"}],"description":"","see":[],"aliasFor":"edgesIter","async":false},{"name":"outEdges","computed":false,"params":[{"name":"optNbunch"},{"name":"optData"}],"description":"","see":[],"aliasFor":"edges","async":false},{"name":"inEdgesIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"A container of nodes.\n     The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"\nIf True, return edge attribute dict in 3-tuple (u,v,data).","defaultValue":"false"}],"description":"Return an iterator over the incoming edges.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"An iterator of (u,v) or (u,v,d) tuples of\n    incoming edges."},"see":"edgesIter","async":false},{"name":"inEdges","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true,"nullable":true},"typeAsHTML":"?Iterable=","description":"A container of nodes.\n     The container will be iterated through once."},{"name":"opt_data","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"\nIf True, return edge attribute dict in 3-tuple (u,v,data).","defaultValue":"false"}],"description":"Return a list of the incoming edges.","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"A list of incoming edges"},"see":"#edges","async":false},{"name":"degreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return an iterator for (node, degree).\n\nThe node degree is the number of edges adjacent to the node.\n\n### Examples\n\n```\nvar G = new jsnx.DiGraph() // or MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter(0));\n// [[0, 1]]\nArray.from(G.degreeIter([0,1]));\n// [[0, 1], [1, 2]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"The iterator returns two-tuples of (node, degree)."},"see":["#degree","#inDegree","#outDegree","#inDegreeIter","#outDegreeIter"],"async":false},{"name":"inDegreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If null or undefined, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return an iterator for (node, in-degree).\n\nThe node in-degree is the number of edges pointing in to the node.\n\n### Examples\n\n```\nvar G = new jsnx.DiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.inDegreeIter(0));\n// [[0, 0]]\nArray.from(G.inDegreeIter([0,1]));\n// [[0, 0], [1, ]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"The iterator returns two-tuples of (node, in-degree)."},"see":["#degree","#inDegree","#outDegree","#outDegreeIter"],"async":false},{"name":"outDegreeIter","computed":false,"params":[{"name":"opt_nbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return an iterator for (node, out-degree).\n\nThe node out-degree is the number of edges pointing in to the node.\n\n### Examples\n\n```\nvar G = new jsnx.DiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.outDegreeIter(0));\n// [[0, 1]]\nArray.from(G.outDegreeIter([0,1]));\n// [[0, 1], [1, ]]\n","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"The iterator returns two-tuples of (node, out-degree)."},"see":["#degree","#inDegree","#outDegree","#inDegreeIter"],"async":false},{"name":"inDegree","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"opt_weight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return the in-degree of a node or nodes.\n\nThe node in-degree is the number of edges pointing in to the node.\n\n### Examples\n\n```\nvar G = new jsnx.DiGraph(); // or MultiDiGraph\nG.addPath([0,1,2,3]);\nG.inDegree(0);\n// 0\nG.inDegree([0,1]);\n// Map {0: 0, 1: 1}\nArray.from(G.inDegree([0,1]).values());\n// [0, 1]\n```","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","description":"A dictionary with nodes as keys and in-degree as values or\n     a number if a single node is specified."},"see":["#degree","#outDegree","#inDegreeIter"],"async":false},{"name":"outDegree","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"Iterable"}],"optional":true},"typeAsHTML":"(Node|Iterable)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"\nThe edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."}],"description":"Return the out-degree of a node or nodes.\n\nThe node out-degree is the number of edges pointing out of the node.\n\n### Examples\n\n```\nvar G = new jsnx.DiGraph(); // or MultiDiGraph\nG.addPath([0,1,2,3]);\nG.outDegree(0);\n// 1\nG.outDegree([0,1]);\n// Map {0: 1, 1: 1}\nArray.from(G.inDegree([0,1]).values());\n// [1, 1]\n```","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","description":"A dictionary with nodes as keys and in-degree as values or\n     a number if a single node is specified."},"see":["#degree","#out_degree","#in_degree_iter"],"async":false},{"name":"clear","computed":false,"params":[],"description":"Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nG.clear();\nG.nodes();\n// []\nG.edges();\n// []\n```","see":[],"async":false},{"name":"isMultigraph","computed":false,"params":[],"description":"Return True if graph is a multigraph, False otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is a multigraph, False otherwise."},"see":[],"async":false},{"name":"isDirected","computed":false,"params":[],"description":"Return True if graph is directed, False otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is directed, False otherwise."},"see":[],"async":false},{"name":"toDirected","computed":false,"params":[],"description":"Return a directed copy of the graph.\n\n### Examples\n\n```\nvar G = new jsnx.Graph(); // or MultiGraph, etc\nG.addPath([0,1]);\nvar H = G.toDirected();\nH.edges();\n// [[0,1], [1,0]]\n```\n\nIf already directed, return a (deep) copy\n\n```\nvar G = new jsnx.DiGraph(); // or MultiDiGraph, etc\nG.addPath([0,1]);\nvar H = G.toDirected();\nH.edges();\n// [[0,1]]\n```\n\n### Notes\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var H = new jsnx.DiGraph(G)` which\nreturns a shallow copy of the data.","returns":{"name":"","type":{"type":"NameExpression","name":"DiGraph","nullable":false},"typeAsHTML":"!DiGraph","description":"A deepcopy of the graph"},"see":[],"async":false},{"name":"toUndirected","computed":false,"params":[{"name":"optReciprocal","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"\nIf True only keep edges that appear in both directions\nin the original digraph."}],"description":"Return an undirected representation of the digraph.\n\n### Notes\n\nIf edges in both directions (u,v) and (v,u) exist in the\ngraph, attributes for the new undirected edge will be a combination of\nthe attributes of the directed edges.  The edge data is updated\nin the (arbitrary) order that the edges are encountered.  For\nmore customized control of the edge attributes use `addEdge()`.\n\nThis returns a \"deepcopy\" of the edge, node, and graph attributes which\nattempts to completely copy all of the data and references.\n\nThis is in contrast to the similar `var H = new jsnx.Graph(G)`\nwhich returns a shallow copy of the data.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","description":"An undirected graph with the same name and nodes and\n    with edge (u,v,data) if either (u,v,data) or (v,u,data)\n    is in the digraph.  If both edges exist in digraph and\n    their edge data is different, only one edge is created\n    with an arbitrary choice of which edge data to use.\n    You must check and correct for this manually if desired."},"see":[],"async":false},{"name":"reverse","computed":false,"params":[{"name":"optCopy","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=True)\n    If True, return a new DiGraph holding the reversed edges.\n    If False, reverse the reverse graph is created using\n    the original graph (this changes the original graph).","defaultValue":"true"}],"description":"Return the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed.","returns":{"name":"","type":{"type":"NameExpression","name":"DiGraph","nullable":false},"typeAsHTML":"!DiGraph","description":"A copy of the graph or the graph itself"},"see":[],"async":false},{"name":"subgraph","computed":false,"params":[{"name":"nbunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nA container of nodes which will be iterated through once."}],"description":"Return the subgraph induced on nodes in `nbunch`.\n\nThe induced subgraph of the graph contains the nodes in `nbunch`\nand the edges between those nodes.\n\n\n### Examples\n\n```\nvar G = new jsnx.Graph() // or DiGraph, MultiGraph, MultiDiGraph, etc\nG.addPath([0,1,2,3]);\nvar H = G.subgraph([0,1,2]);\nH.edges();\n// [[0,1], [1,2]]\n```\n\n### Notes\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`new jsnx.Graph(G.subgraph(nbunch))`.\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\n\n```\nG.removeNodesFrom(G.nodes().filter(function(n) {\n     return nbunch.indexOf(n) > -1;\n}))\n```","returns":{"name":"","type":{"type":"NameExpression","name":"DiGraph"},"typeAsHTML":"DiGraph","description":"A subgraph of the graph with the same edge\n attributes."},"see":[],"async":false}],"properties":[],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"params":[],"description":"Holds the graph type (class) name for information.","see":[],"async":false,"readonly":true}],"constructor":{"name":"DiGraph","computed":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"\nData to initialize graph.  If data=None (default) an empty\ngraph is created.  The data can be an edge list, or any\nJSNetworkX graph object."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"\nAttributes to add to graph as key=value pairs."}],"description":"","see":[],"async":false},"categories":["classes"]},"MultiGraph":{"name":"MultiGraph","aliases":["MultiGraph","classes.MultiGraph"],"isClass":true,"description":"An undirected graph class that can store multiedges.\n\nMultiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes. A MultiGraph holds undirected edges.\nSelf loops are allowed.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\n### Examples\n\nCreate an empty graph structure (a \"null graph\") with no nodes and no edges.\n\n```\nvar G = jsnx.MultiGraph();\n```\n\nG can be grown in several ways.\n\n#### Nodes\n\nAdd one node at a time:\n\n```\nG.addNode(1);\n```\n\nAdd the nodes from any iterable:\n\n```\nG.addNodesFrom([2, 3]);\nvar H = jsnx.Graph();\nH.addPath([0,1,2,3,4,5,6,7,8,9]);\nG.addNodesFrom(h);\n```\n\nIn addition to strings and integers, any object that implements a custom\n`toString` method can be used as node. For example, arrays:\n\n```\nG.addNode([1,2]);\n```\n\n#### Edges\n\nA graph can also be grown by adding edges.\n\nAdd one edge,\n\n```\nG.addEdge(1, 2);\n```\n\na list or collection of edges,\n\n```\nG.addEdgesFrom([[1,2], [1,3]]);\nG.addEdgesFrom(H.edges());\n```\n\nIf some edges connect nodes not yet in the graph, the nodes are added\nautomatically. If an edge already exists, an addition edge is created and\nstored using a key to identify the edge. By default, the key is the lowest\nunused integer.\n\n```\nG.addEdgesFrom([[4,5,{route: 282}], [4,5,{route: 37}]]);\nG.get(4);\n// Map { 3: {0: {}}, 5: {0: {}, 1: {route: 282}, 2: {route: 37}}}\n```\n\n#### Attributes\n\nEach graph, node and edge can hold key/value attribute pairs in an associated\nattribute \"dictionary\" (object). By defauly these are empty, but can be added\nor changed using `addEdge` or `addNode`.\n\n```\nvar G = jsnx.MultiGraph(null, {day: Friday}):\nG.graph\n// {day: 'Friday'}\n\nG.addNode(1, {time: '5pm'});\nG.addNodesFrom([3], {time: '2pm'});\nG.nodes(true);\n// [[1, {time: '5pm'}], [3, {time: '2pm'}]]\n```","extends":"Graph","methods":[{"name":"addEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"string"}],"optional":true,"nullable":true},"typeAsHTML":"?(number|string)=","description":"identifier\n    Used to distinguish multiedges between a pair of nodes. Default is\n    the lowest unused integer."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true,"nullable":true},"typeAsHTML":"?Object=","description":"Dictionary of edge attributes.\n   Key/value pairs will update existing data associated with the edge."}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by providing\na dictionary with key/value pairs.\n\n### Notes:\n\nTo replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created.\n\nNetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n'weight' to enable weighted graph algorithms.\n\n### Example\n\nThe following all add the edge [1,2] to the graph G:\n\n```\nvar G = jsnx.MultiGraph();\nvar e = [1,2];\nG.addEdge(1, 2);\nG.addEdge.apply(G, e);\nG.addEdgesFrom([e]);\n```\nAssociate data to edges by passing a data object:\n\n```\nG.addEdge(1, 2, {weight: 3});\nG.addEdge(1, 2, 0, {weight: 4}); // update data for key=0\nG.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});\n```","see":"#addEdgesFrom","async":false},{"name":"addEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"container of edges\n    Each edge given in the container will be added to the\n    graph. The edges can be:\n\n        - 2-tuples (u,v) or\n        - 3-tuples (u,v,d) for an edge attribute dict d or\n        - 4-tuples (u,v,k,d) for an edge identified by key k"},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Dictionary of edge attributes.\n     Key/value pairs will update existing data associated with each edge."}],"description":"Add all the edges in `ebunch`.\n\nAdding the same edge twice has no effect but any edge data will be updated\nwhen each duplicate edge is added.\n\nEdge attributes specified in edges as a tuple take precedence over the\nattributes specified generally.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdgesFrom([[0,1], [1,2]]);\n```\n\nAssociate data to edges\n\n```\nG.addEdgesFrom([[1,2], [2,3]], {weight: 3});\nG.addEdgesFrom([[1,2], [2,3]], {label: 'WN2898'});\n```","see":["#addEdge","#addWeightedEdgesFrom"],"async":false},{"name":"removeEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"string"}],"optional":true},"typeAsHTML":"(number|string)=","description":"\nUsed to distinguish multiple edges between a pair of nodes.\nIf null or undefined remove a single (arbitrary) edge between u and v."}],"description":"Remove an edge between u and v.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.removeEdge(0, 1);\n```\n\nFor multiple edges\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdgesFrom([[1,2], [1,2], [1,2]]);\nG.removeEdge(1, 2); // remove a single edge\n```\n\nFor edges with keys\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdge(1, 2, 'first');\nG.addEdge(1, 2, 'second');\nG.removeEdge(1, 2, 'second');\n```","see":"#removeEdgesFrom","async":false},{"name":"removeEdgesFrom","computed":false,"params":[{"name":"ebunch","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","description":"list or container of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n\n      - 2-tuples (u,v) All edges between u and v are removed.\n      - 3-tuples (u,v,key) The edge identified by key is removed."}],"description":"Remove all edges specified in `ebunch`.\n\nWill fail silently if an edge in `ebunch` is not in the graph.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nvar ebunch = [[1,2], [2,3]];\nG.removeEdgesFrom(ebunch);\n```\n\nRemoving multiple copies of edges.\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdgesFrom([[1,2], [1,2], [1,2]]);\nG.removeEdgesFrom([[1,2], [1,2]]);\nG.edges();\n// [[1,2]]\n```","see":"#removeEdge","async":false},{"name":"hasEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}],"optional":true},"typeAsHTML":"(string|number)=","description":"If specified return true only\n    if the edge with key is found."}],"description":"Return True if the graph has an edge between nodes u and v.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.hasEdge(0,1);\n// true\nG.addEdge(0, 1, 'a');\nG.hasEdge(0, 1, 'a');\n// true\n```\n\nThe following syntax are equivalent:\n\n```\nG.hasEdge(0, 1);\n// true\nG.get(0).has(1);\n// true\n```","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"true if edge is in the graph, false otherwise."},"see":[],"async":false},{"name":"edges","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true,"nullable":true},"typeAsHTML":"?NodeContainer=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"(default=False)\n    Return two tuples (u,v) (False) or three-tuples (u,v,data) (True)."},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"(default=False)\n    Return two tuples (u,v) (False) or three-tuples (u,v,key) (True)."}],"description":"Return a list of edges.\n\nEdges are returned as tuples with optional data and keys in the order\n(node, neighbor, key, data).\n\nNodes in `nbunch` that are not in the graph will be (quietly) ignored.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.edges();\n// [[0,1], [1,2], [2,3]]\nG.edges(true);\n// [[0,1,{}], [1,2,{}], [2,3,{}]]\nG.edges(false, true);\n// [[0,1,0], [1,2,0], [2,3,0]]\nG.edges(true, true);\n// [[0,1,0,{}], [1,2,0,{}], [2,3,0,{}]]\nG.edges([0,3]);\n// [[0,1], [3, 2]]\nG.edges(0);\n// [[0,1]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","description":"list of edge tuples\n    Edges that are adjacent to any node in nbunch, or a list\n    of all edges if nbunch is not specified."},"see":"#edgesIter","async":false},{"name":"edgesIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"NodeContainer"},{"type":"NameExpression","name":"boolean"}],"optional":true,"nullable":true},"typeAsHTML":"?(NodeContainer|boolean)=","description":"A container of nodes.\n    The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"(default=False)\n    If True, return edge attribute dict with each edge.","defaultValue":"false"},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"(default=False)\n    If True, return edge keys with each edge.","defaultValue":"false"}],"description":"Return an iterator over edges.\n\nEdges are returned as tuples with optional data and keys\nin the order (node, neighbor, key, data).\n\nNodes in nbunch that are not in the graph will be (quietly) ignored.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.edgesIter);\n// [[0,1], [1,2], [2,3]]\nArray.from(G.edges(true));\n// [[0,1,{}], [1,2,{}], [2,3,{}]]\nArray.from(G.edges(false, true));\n// [[0,1,0], [1,2,0], [2,3,0]]\nArray.from(G.edges(true, true));\n// [[0,1,0,{}], [1,2,0,{}], [2,3,0,{}]]\nArray.from(G.edges([0,3]));\n// [[0,1], [3, 2]]\nArray.from(G.edges(0));\n// [[0,1]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"An iterator of (u,v), (u,v,d) or (u,v,key,d) tuples of edges."},"see":"#edges","async":false},{"name":"getEdgeData","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}],"optional":true},"typeAsHTML":"(string|number)=","description":"Return data only for the edge with\n    specified key."},{"name":"optDefault","type":{"type":"NameExpression","name":"T","optional":true},"typeAsHTML":"T=","description":"Value to return if the edge (u,v) is not found."}],"description":"Return the attribute dictionary associated with edge (u,v).\n\n### Example\n\n```\nvar G = jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.getEdgeData(0, 1);\n// {0: {}}\nG.getEdgeData('a', 'b', null, 0); // edge not in graph, return 0\n// 0\n```","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"T"}]},"typeAsHTML":"(Object|T)","description":"The edge attribute dictionary."},"see":[],"async":false},{"name":"degreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true,"nullable":true},"typeAsHTML":"?(Node|NodeContainer)=","description":"A container of nodes\n   The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","description":"The edge attribute that holds the numerical\n   value used as a weight.  If undefined, then each edge has weight 1.\n   The degree is the sum of the edge weights adjacent to the node."}],"description":"Return an iterator for (node, degree).\n\nThe node degree is the number of edges adjacent to the node.\n\n### Example\n\n```\nvar G = new jsnx.Graph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter(0));\n// [[0,1]]  // node 0 with degree 1\nArray.from(G.degreeIter([0,1]));\n// [[0,1], [1,2]]","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","description":"The iterator returns two-tuples of (node, degree)."},"see":"#degree","async":false},{"name":"isMultigraph","computed":false,"params":[],"description":"Return true if graph is a multigraph, false otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"true if graph is a multigraph, false otherwise."},"see":[],"async":false},{"name":"isDirected","computed":false,"params":[],"description":"Return true if graph is directed, false otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is directed, False otherwise."},"see":[],"async":false},{"name":"toDirected","computed":false,"params":[],"description":"Return a directed representation of the graph.\n\n### Notes\n\nThis returns a \"deepcopy\" of the edge, node, and graph attributes which\nattempts to completely copy all of the data and references.\n\nThis is in contrast to the similar D = DiGraph(G) which returns a shallow\ncopy of the data.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1]);\nvar H = G.toDirected();\nG.edges();\n// [[0,1], [1,0]]\n```\n\nIf already directed, return a (deep) copy\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1]);\nvar H = G.toDirected();\nG.edges();\n// [[0,1]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"MultiDiGraph","nullable":false},"typeAsHTML":"!MultiDiGraph","description":"A directed graph with the same name, same nodes, and with\n    each edge (u,v,data) replaced by two directed edges\n    (u,v,data) and (v,u,data)."},"see":[],"async":false},{"name":"selfloopEdges","computed":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=False)\n   Return selfloop edges as two tuples (u,v) (data=False)\n   or three-tuples (u,v,data) (data=True)","defaultValue":"false"},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=False)\n    If True, return edge keys with each edge","defaultValue":"false"}],"description":"Return a list of selfloop edges.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdge(1, 1);\nG.addEdge(1, 2);\nG.selfloopEdges();\n// [[1,1]]\nG.selfloopEdges(true);\n// [[1,1,{}]]\nG.selfloopEdges(false, true);\n// [[1,1,0]]\nG.selfloopEdges(true, true);\n// [[1,1,0,{}]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"A list of all selfloop edges"},"see":["#nodesWithSelfloops","#numberOfSelfloops"],"async":false},{"name":"numberOfEdges","computed":false,"params":[{"name":"optU","type":{"type":"NameExpression","name":"Node","optional":true},"typeAsHTML":"Node=","description":"node"},{"name":"optV","type":{"type":"NameExpression","name":"Node","optional":true},"typeAsHTML":"Node=","description":"node\n    If u and v are specified, return the number of edges between\n    u and v. Otherwise return the total number of all edges."}],"description":"Return the number of edges between two nodes.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.numberOfEdges();\n// 3\nG.numberOfEdges(0,1);\n// 1\n```","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of edges in the graph.\n    If nodes u and v are specified return the number of edges between\n    those nodes."},"see":"#size","async":false},{"name":"subgraph","computed":false,"params":[{"name":"nbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","description":"A container of nodes which will be\n    iterated through once."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nThe induced subgraph of the graph contains the nodes in nbunch and the\nedges between those nodes.\n\n### Notes\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`jsnx.Graph(G.subgraph(nbunch))`\n\nIf edge attributes are containers, a deep copy can be obtained using:\n`G.subgraph(nbunch).copy()`.\n\n### Example\n\n```\nvar G = new jsnx.Graph();\nG.addPath([0,1,2,3]);\nvar H = G.subgraph([0,1,2]);\nH.edges();\n// [[0,1], [1,2]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"MultiGraph"},"typeAsHTML":"MultiGraph","description":"A subgraph of the graph with the same edge attributes."},"see":[],"async":false}],"properties":[],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"params":[],"description":"Holds the graph type (class) name for information.\nThis is compatible to Pythons __name__ property.","see":[],"async":false,"readonly":true}],"constructor":{"name":"MultiGraph","computed":false,"params":[{"name":"optData","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","description":"Data to initialze graph.\n    If no data is provided, an empty graph is created. The data can be\n    an edge list or any graph object."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"Attributes to add to graph as key=value pairs."}],"description":"","see":[],"async":false},"categories":["classes"]},"MultiDiGraph":{"name":"MultiDiGraph","aliases":["MultiDiGraph","classes.MultiDiGraph"],"isClass":true,"description":"A directed graph class that can store multiedges.\n\nMultiedges are multiple edges between two nodes. Each edge can hold optional\ndata or attributes.\n\nA MultiDiGraph holds directed edges. Self loops are allowed. Edges are\nrespresented as links between nodes with optional key/value attributes.\n\n### Example\n\nCreate an empty graph structure (a \"null graph\") with no nodes and no edges:\n\n```\nvar G = new jsnx.MultiDiGraph();\n```\n\nG can be grown in several ways.\n\n#### Nodes\n\nAdd one node at a time:\n\n```\nG.addNode(1);\n```\n\nAdd the nodes from any iterable:\n\n```\nG.addNodesFrom([2,3]);\nvar H = new jsnx.Graph();\nH.addPath([0,1,2,3,4,5]);\nG.addNodesFrom(H);\n```\n\nIn addition to strings and integers, any object that implements a custom\n`toString` method can represent a node.\n\n#### Edges\n\n`G` can also be grown by adding edges. Add one edge,\n\n```\nG.addEdge(1, 2);\n```\n\na list of edges,\n\n```\nG.addEdgesFrom([[1,2], [1,3]]);\n```\n\nor a collection of edges\n\n```\nG.addEdgesFrom(H.edges());\n```\n\nIf some edges connect nodes not yet in the graph, the nodes are added\nautomatically. If an edge already exists, an additional edge is created and\nstored using a key to identify the edge. By default the key is the lowest\nunused integer.\n\n```\nG.addEdgesFrom([[4,5,{route:282}], [4,5,{route:37}]]);\nG.get(4);\n// Map {5: {0: {}, 1: {route: 282}, 2: {route: 37}}}\n\n#### Attributes\n\nEach graph, node and edge can hold key/value attribute pairs in an associated\nattribute object. By default these are empty, but can be added or changed\nusing `addEdge` or `addNode`.\n\n```\nG.addNode(1, {time: '5pm'});\nG.addNodesFrom([3], {time: '2pm'});\nG.nodes(true);\n// [[1, {time: '5pm'}], [3, {time: '2pm'}]]\n```\n\nAdd edge attributes using `addEdge` and `addEdgesFrom`:\n\n```\nG.addEdge(1, 2, {weight: 4.7});\nG.addEdgesFrom([[3,4], [4,5]], {color: 'red'});\nG.addEdgesFrom([[1,2,{color: 'blue'}], [2,3,{weight: 8}]]);\n```","extends":"DiGraph","methods":[{"name":"addEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}]},"typeAsHTML":"(string|number)","description":"(default=lowest unused integer) Used to\n distinguish multiedges between a pair of nodes."},{"name":"opAttrDict","type":{"type":"NameExpression","name":"Object"},"typeAsHTML":"Object","description":"Object of edge attributes. Key/value pairs will\n update existing data associated with the edge."}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are not already in\nthe graph.\n\nEdge attributes can be specified by providing an object with key/value\npairs.\n\n### Note\n\nTo replace/update edge data, use the optional key argument to identify a\nunique edge. Otherwise a new edge will be created.\n\n### Example\n\nThe following add the edge e=(1,2) to graph G:\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addEdge(1, 2);\nG.addEdgesFrom([[1,2]]);\n```\n\nAssociate data to edges using keywords:\n\n```\nG.addEdge(1, 2, {weight: 3});\nG.addEdge(1, 2, 0, {weight: 4}); // update data for key=0\nG.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});\n```","see":[],"async":false},{"name":"removeEdge","computed":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}]},"typeAsHTML":"(string|number)","description":"Used to distinguish multiple edges between\n a pair of nodes. If undefined, remove a single (arbitrary) edge between\n u and v."}],"description":"Remove an edge between u and v.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nG.removeEdge(0, 1);\n```\n\nFor multiple edges:\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addEdgesFrom([[1,2], [1,2], [1,2]]);\nG.removeEdge(1, 2); // remove a single (arbitrary) edge\n```\n\nFor edges with keys:\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addEdge(1, 2, 'first');\nG.addEdge(1, 2, 'second');\nG.removeEdge(1, 2, 'second');\n```","see":[],"async":false},{"name":"edgesIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"(default=all nodes) A container of nodes.\n The container will be iterated over only once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"(default=false) If true, return edge attribute\n dictionaries with each edge.","defaultValue":"false"},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"(default=flase) If true, return edge keys with\n each edge.","defaultValue":"false"}],"description":"Return an iterator over the edges.\n\nEdges are returned as tuples with optional data and keys in the order\n`(node, neighbor, key, data)`.\n\n### Note\n\nNodes in `optNbunch` that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.edgesIter());\n// [[0,1], [1,2], [2,3]]\nArray.from(G.edgesIter(true));\n// [[0,1,{}], [1,2,{}], [2,3,{}]]\nArray.from(G.edgesIter([0,2]));\n// [[0,1], [2,3]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"An iterator of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` edges"},"see":[],"aliasFor":"outEdgesIter","async":false},{"name":"outEdgesIter","computed":false,"params":[{"name":"optNbunch"},{"name":"optData"},{"name":"optKeys"}],"description":"","see":[],"aliasFor":"edgesIter","async":false},{"name":"outEdges","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"(default=all nodes) A container of nodes.\n The container will be iterated over only once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"(default=false) If true, return edge attribute\n dictionaries with each edge."},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"(default=flase) If true, return edge keys with\n each edge."}],"description":"Return a list of the outgoing edges.\n\nEdges are returned as tuples with optional data and keys in the order\n`(node, neighbor, key, data)`.\n\n### Note\n\nNodes in `optNbunch` that are not in the graph will be (quietly) ignored.\nFor directed graphs `edges()` is the same as `outEdges()`.","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"A list of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` tuples of\n edges"},"see":"inEdges","async":false},{"name":"inEdgesIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default=all nodes) A container of nodes.\n The container will be iterated over only once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=false) If true, return edge attribute\n dictionaries with each edge.","defaultValue":"false"},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=flase) If true, return edge keys with\n each edge.","defaultValue":"false"}],"description":"Return an iterator over the incoming edges.\n\nEdges are returned as tuples with optional data and keys in the order\n`(node, neighbor, key, data)`.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"An iterator of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` edges"},"see":"edgesIter","async":false},{"name":"inEdges","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default=all nodes) A container of nodes.\n The container will be iterated over only once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=false) If true, return edge attribute\n dictionaries with each edge."},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"(default=flase) If true, return edge keys with\n each edge."}],"description":"Return a list of the incoming edges.","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"A list of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` tuples of\n edges"},"see":"outEdges","async":false},{"name":"degreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default=all nodes) A container of nodes.\n The container will be iterated through once."},{"name":"optString","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"(default=null)\n The edge attribute that holds the numerical value used as a weight. If\n None, then each edge has weight 1.\n The degree is the sum of the edge weights."}],"description":"Return an iterator for `(node, degree)`.\n\nThe node degree is the number of edges adjacent to the node.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter([0,1]));\n// [[0,1], [1,2]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"The iterator returns two-tuples of `(node, degree)`."},"see":[],"async":false},{"name":"inDegreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default=all nodes) A container of nodes.\n The container will be iterated through once."},{"name":"optString","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"(default=null)\n The edge attribute that holds the numerical value used as a weight. If\n None, then each edge has weight 1.\n The degree is the sum of the edge weights."}],"description":"Return an iterator for `(node, in-degree)`.\n\nThe node in-degree is the number of edges pointing to the node.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter([0,1]));\n// [[0,0], [1,1]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"The iterator returns two-tuples of `(node, degree)`."},"see":[],"async":false},{"name":"outDegreeIter","computed":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"(default=all nodes) A container of nodes.\n The container will be iterated through once."},{"name":"optString","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"(default=null)\n The edge attribute that holds the numerical value used as a weight. If\n None, then each edge has weight 1.\n The degree is the sum of the edge weights."}],"description":"Return an iterator for `(node, out-degree)`.\n\nThe node out-degree is the number of edges pointing out of the node.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter([0,1]));\n// [[0,1], [1,1]]\n```","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"The iterator returns two-tuples of `(node, degree)`."},"see":[],"async":false},{"name":"isMultigraph","computed":false,"params":[],"description":"Return True if graph is a multigraph, False otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is a multigraph, False otherwise."},"see":[],"async":false},{"name":"isDirected","computed":false,"params":[],"description":"Return True if graph is directed, False otherwise.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is directed, False otherwise."},"see":[],"async":false},{"name":"toDirected","computed":false,"params":[],"description":"Return a directed copy of the graph.\n\n### Notes\n\nThis returns a deep copy of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var G = new MultiDiGraph(D);`, which\nreturns a shallow copy of the data.","returns":{"name":"","type":{"type":"NameExpression","name":"MultiDiGraph"},"typeAsHTML":"MultiDiGraph","description":"A deep copy of the graph."},"see":[],"async":false},{"name":"toUndirected","computed":false,"params":[{"name":"optReciprocal","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"If true, only keep edges that appear in\n both directions in the original digraph."}],"description":"Return an undirected representation of the digraph.\n\n### Notes\n\nThe result is an undirected graph with the same name, nodes and\nwith edge `(u,v,data)` if either `(u,v,data)` or `(v,u,data)`\nis in the digraph.  If both edges exist in digraph and\ntheir edge data is different, only one edge is created\nwith an arbitrary choice of which edge data to use.\nYou must check and correct for this manually if desired.\n\nThis returns a deep copy of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var G = new MultiGraph(D);`, which\nreturns a shallow copy of the data.","returns":{"type":{"type":"NameExpression","name":"MultiGraph"},"typeAsHTML":"MultiGraph"},"see":[],"async":false},{"name":"subgraph","computed":false,"params":[{"name":"nBunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"A container of nodes which will be iterated\n through once."}],"description":"Return the subgraph induced on nodes in `nbunch`.\n\nThe induced subgraph of the graph contains the nodes in `optNbunch` and the\nedges between those nodes.\n\n### Notes\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`jsnx.MultiDiGraph(G.subgraph(nbunch))`.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nvar H = G.subgraph([0,1,2]);\nH.edges();\n// [[0,1], [1,2]]\n```","returns":{"type":{"type":"NameExpression","name":"MultiDiGraph"},"typeAsHTML":"MultiDiGraph"},"see":[],"async":false},{"name":"reverse","computed":false,"params":[{"name":"optCopy","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"If true, return a new MultiDiGraph holding the\n reversed edges. If false, the reverse graph is created using the original\n graph (this changes the original graph).","defaultValue":"true"}],"description":"Return the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges but with the\ndirections of the edges reversed.","returns":{"type":{"type":"NameExpression","name":"MultiDiGraph","nullable":true},"typeAsHTML":"?MultiDiGraph"},"see":[],"async":false}],"properties":[],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"params":[],"description":"Holds the graph type (class) name for information.","see":[],"async":false,"readonly":true}],"constructor":{"name":"MultiDiGraph","computed":false,"params":[{"name":"optData","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"Array"},{"type":"NameExpression","name":"Graph"}]},"typeAsHTML":"(Object|Array|Graph)","description":"Data to initialize graph.\n If no data is passed, an empty graph is created. The data can be an edge\n list, or any JSNetworkX graph object."},{"name":"opt_attr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"(default= no attributes)\n     Attributes to add to graph as key=value pairs."}],"description":"","see":[],"async":false},"categories":["classes"]},"nodes":{"name":"nodes","aliases":["nodes","classes.nodes","classes.functions.nodes","functions.nodes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return a copy of the graph nodes in a list.","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"List of nodes"},"see":[],"async":false,"categories":["classes","functions"]},"nodesIter":{"name":"nodesIter","aliases":["nodesIter","classes.nodesIter","classes.functions.nodesIter","functions.nodesIter"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return an iterator over the graph nodes.","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"Iterator over graph nodes"},"see":[],"async":false,"categories":["classes","functions"]},"edges":{"name":"edges","aliases":["edges","classes.edges","classes.functions.edges","functions.edges"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"opt_nbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","description":"Nodes"}],"description":"Return a list of edges adjacent to nodes in nbunch.\n\nReturn all edges if nbunch is unspecified or nbunch=None.\nFor digraphs, edges=out_edges","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"List of edges"},"see":[],"async":false,"categories":["classes","functions"]},"edgesIter":{"name":"edgesIter","aliases":["edgesIter","classes.edgesIter","classes.functions.edgesIter","functions.edgesIter"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"opt_nbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","description":"Nodes"}],"description":"Return iterator over  edges adjacent to nodes in nbunch.\n\nReturn all edges if nbunch is unspecified or nbunch=None.\nFor digraphs, edges=out_edges","returns":{"name":"","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","description":"Iterator over edges"},"see":[],"async":false,"categories":["classes","functions"]},"degree":{"name":"degree","aliases":["degree","classes.degree","classes.functions.degree","functions.degree"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"opt_nbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","description":"Nodes"},{"name":"opt_weight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","description":"Weight attribute name"}],"description":"Return degree of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of *all* nodes.","returns":{"name":"","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","description":"Degree of node(s)"},"see":[],"async":false,"categories":["classes","functions"]},"neighbors":{"name":"neighbors","aliases":["neighbors","classes.neighbors","classes.functions.neighbors","functions.neighbors"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","description":"Node"}],"description":"Return a list of nodes connected to node n.","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"List of nodes"},"see":[],"async":false,"categories":["classes","functions"]},"numberOfNodes":{"name":"numberOfNodes","aliases":["numberOfNodes","classes.numberOfNodes","classes.functions.numberOfNodes","functions.numberOfNodes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return the number of nodes in the graph.","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Number of nodes"},"see":[],"async":false,"categories":["classes","functions"]},"numberOfEdges":{"name":"numberOfEdges","aliases":["numberOfEdges","classes.numberOfEdges","classes.functions.numberOfEdges","functions.numberOfEdges"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return the number of edges in the graph.","returns":{"name":"","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Number of edges"},"see":[],"async":false,"categories":["classes","functions"]},"density":{"name":"density","aliases":["density","classes.density","classes.functions.density","functions.density"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return the density of a graph.\nThe density for undirected graphs is\n\n```math\nd = \\frac{2m}{n(n-1)}\n```\n\nand for directed graphs is\n\n```math\n\\frac{m}{n(n-1)}\n```\n\nwhere n is the number of nodes and m is the number of edges in G\n\nThe density is 0 for an graph without edges and 1.0 for a complete graph.\nThe density of multigraphs can be higher than 1.","returns":{"name":"Density","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"see":[],"async":false,"categories":["classes","functions"]},"degreeHistogram":{"name":"degreeHistogram","aliases":["degreeHistogram","classes.degreeHistogram","classes.functions.degreeHistogram","functions.degreeHistogram"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return a list of the frequency of each degree value.\n\nNote: the bins are width one, hence list.length can be large\n(Order(number_of_edges))\n","returns":{"name":"","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"A list of frequencies of degrees.\n    The degree values are the index in the list."},"see":[],"async":false,"categories":["classes","functions"]},"isDirected":{"name":"isDirected","aliases":["isDirected","classes.isDirected","classes.functions.isDirected","functions.isDirected"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return True if graph is directed.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is directed"},"see":[],"async":false,"categories":["classes","functions"]},"freeze":{"name":"freeze","aliases":["freeze","classes.freeze","classes.functions.freeze","functions.freeze"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Modify graph to prevent addition of nodes or edges.\n\nThis does not prevent modification of edge data.\nTo \"unfreeze\" a graph you must make a copy.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A reference to the input graph"},"see":"#is_frozen","async":false,"categories":["classes","functions"]},"isFrozen":{"name":"isFrozen","aliases":["isFrozen","classes.isFrozen","classes.functions.isFrozen","functions.isFrozen"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"}],"description":"Return True if graph is frozen.","returns":{"name":"","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"True if graph is frozen."},"see":"#freeze","async":false,"categories":["classes","functions"]},"subgraph":{"name":"subgraph","aliases":["subgraph","classes.subgraph","classes.functions.subgraph","functions.subgraph"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"nbunch","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","description":"\nA container of nodes that will be iterated through once (thus\nit should be an iterator or be iterable).  Each element of the\ncontainer should be a valid node type: any hashable type except\nNone.  If nbunch is None, return all edges data in the graph.\nNodes in nbunch that are not in the graph will be (quietly)\nignored."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nNote:  subgraph(G) calls G.subgraph()","returns":{"name":"Subgraph","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["classes","functions"]},"createEmptyCopy":{"name":"createEmptyCopy","aliases":["createEmptyCopy","classes.createEmptyCopy","classes.functions.createEmptyCopy","functions.createEmptyCopy"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"opt_with_nodes","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"(default=True)\n    Include nodes.","defaultValue":"true"}],"description":"Return a copy of the graph G with all of the edges removed.\n\nNotes: Graph, node, and edge data is not propagated to the new graph.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A copy of the graph"},"see":[],"async":false,"categories":["classes","functions"]},"info":{"name":"info","aliases":["info","classes.info","classes.functions.info","functions.info"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"opt_n","type":{"type":"NameExpression","name":"Node","optional":true},"typeAsHTML":"Node=","description":"A node in the graph G"}],"description":"Print short summary of information for the graph G or the node n.","returns":{"name":"Info","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string"},"see":[],"async":false,"categories":["classes","functions"]},"setNodeAttributes":{"name":"setNodeAttributes","aliases":["setNodeAttributes","classes.setNodeAttributes","classes.functions.setNodeAttributes","functions.setNodeAttributes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","description":"Attribute name"},{"name":"attributes","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(Object|Map)","description":"Dictionary of attributes keyed by node"}],"description":"Set node attributes from dictionary of nodes and values","see":[],"async":false,"categories":["classes","functions"]},"getNodeAttributes":{"name":"getNodeAttributes","aliases":["getNodeAttributes","classes.getNodeAttributes","classes.functions.getNodeAttributes","functions.getNodeAttributes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","description":"Attribute name"}],"description":"Get node attributes from graph","returns":{"name":"","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","description":"Dictionary of attributes keyed by node."},"see":[],"async":false,"categories":["classes","functions"]},"setEdgeAttributes":{"name":"setEdgeAttributes","aliases":["setEdgeAttributes","classes.setEdgeAttributes","classes.functions.setEdgeAttributes","functions.setEdgeAttributes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","description":"Attribute name"},{"name":"attributes","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","description":"\nDictionary of attributes keyed by edge (tuple)."}],"description":"Set edge attributes from dictionary of edge tuples and values","see":[],"async":false,"categories":["classes","functions"]},"getEdgeAttributes":{"name":"getEdgeAttributes","aliases":["getEdgeAttributes","classes.getEdgeAttributes","classes.functions.getEdgeAttributes","functions.getEdgeAttributes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","description":"Attribute name"}],"description":"Get edge attributes from graph\n\nSince keys can only be strings in JavaScript, the edge is returned as\n{@code \"node1,node2\"} string. You'd have to call {@code .split(',')} on\nthe keys to extract the actual node names.","returns":{"name":"","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","description":"Dictionary of attributes keyed by edge."},"see":[],"async":false,"categories":["classes","functions"]},"toNetworkxGraph":{"name":"toNetworkxGraph","aliases":["toNetworkxGraph","convert.toNetworkxGraph"],"params":[{"name":"data","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","description":"An object to be converted\n Current accepts types are:\n\n - any JSNetworkX graph\n - object of objects\n - object of lists\n - list of edges"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"NetworkX graph\n   Use specified graph for result.  Otherwise a new graph is created."},{"name":"optMultigraphInput","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"\nIf `true` and  `data` is an object of objects,\ntry to create a multigraph assuming object of objects of lists\nIf data and createUsing are both multigraphs then create\na multigraph from a multigraph.","defaultValue":"false"}],"description":"Make a JSNetworkX graph from a known data structure.\n\nThe preferred way to call this is automatically from the class constructor\n\n```\nvar data = {0: {1 : {weight: 1}}} // object of objects single edge (0,1)\nvar G = new jsnx.Graph(d);\n```\n\ninstead of the equivalent\n\n```\nvar G = jsnx.fromDictOfDicts(d);\n```","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["convert"]},"convertToUndirected":{"name":"convertToUndirected","aliases":["convertToUndirected","convert.convertToUndirected"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph to convert"}],"description":"Return a new undirected representation of the graph G.","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},"see":[],"async":false,"categories":["convert"]},"convertToDirected":{"name":"convertToDirected","aliases":["convertToDirected","convert.convertToDirected"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"Graph to convert"}],"description":"Return a new directed representation of the graph G.","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},"see":[],"async":false,"categories":["convert"]},"toDictOfLists":{"name":"toDictOfLists","aliases":["toDictOfLists","convert.toDictOfLists"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A JSNetworkX graph"},{"name":"optNodelist","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Use only nodes specified in nodelist"}],"description":"Return adjacency representation of graph as a dictionary of lists.\n\nCompletely ignores edge data for MultiGraph and MultiDiGraph.","returns":{"type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Object"},"applications":[{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!Object.&lt;Array>"},"see":[],"async":false,"categories":["convert"]},"fromDictOfLists":{"name":"fromDictOfLists","aliases":["fromDictOfLists","convert.fromDictOfLists"],"params":[{"name":"d","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Object"},"applications":[{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!Object.&lt;Array>","description":"A dictionary of lists adjacency representation."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Use specified graph for result.\n  Otherwise a new graph is created."}],"description":"Return a graph from a dictionary of lists.\n\n### Examples\n\n```\nvar data = {0: [1]}; // single edge (0,1)\nvar G = jsnx.fromDictOfLists(data);\n// or\nvar G = new jsnx.Graph(data);\n```","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},"see":[],"async":false,"categories":["convert"]},"toDictOfDicts":{"name":"toDictOfDicts","aliases":["toDictOfDicts","convert.toDictOfDicts"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A jsnx Graph"},{"name":"optNodelist","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Use only nodes specified in nodelist"},{"name":"optEdgeData","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","description":"If provided,  the value of the dictionary will\n    be set to edgeData for all edges.  This is useful to make\n    an adjacency matrix type representation with 1 as the edge data.\n    If edgedata is null or undefined, the edgedata in G is used to fill\n    the values.\n    If G is a multigraph, the edgedata is a dict for each pair (u,v)."}],"description":"Return adjacency representation of graph as a dictionary of dictionaries.","returns":{"type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Object"},"applications":[{"type":"NameExpression","name":"Object"}],"nullable":false},"typeAsHTML":"!Object.&lt;Object>"},"see":[],"async":false,"categories":["convert"]},"fromDictOfDicts":{"name":"fromDictOfDicts","aliases":["fromDictOfDicts","convert.fromDictOfDicts"],"params":[{"name":"d","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Object"},"applications":[{"type":"NameExpression","name":"Object","nullable":false}],"nullable":false},"typeAsHTML":"!Object.&lt;!Object>","description":"A dictionary of dictionaries adjacency\n    representation."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Use specified graph for result.\n    Otherwise a new graph is created."},{"name":"optMultigraphInput","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"\nWhen `true`, the values of the inner object are assumed\nto be containers of edge data for multiple edges.\nOtherwise this routine assumes the edge data are singletons.","defaultValue":"false"}],"description":"Return a graph from a dictionary of dictionaries.\n\n\n### Examples\n\n```\nvar data = {0: {1: {weight: 1}}}; // single edge (0,1)\nvar G = jsnx.fromDictOfDicts(data);\n// or\nvar G = new jsnx.Graph(data);\n```","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["convert"]},"toEdgelist":{"name":"toEdgelist","aliases":["toEdgelist","convert.toEdgelist"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A JSNetworkX graph"},{"name":"optNodelist","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","description":"Use only nodes specified in nodelist"}],"description":"Return a list of edges in the graph.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"},"see":[],"async":false,"categories":["convert"]},"fromEdgelist":{"name":"fromEdgelist","aliases":["fromEdgelist","convert.fromEdgelist"],"params":[{"name":"edgelist","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"Array"}]},"typeAsHTML":"Array.&lt;Array>","description":"Edge tuples"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Use specified graph for result.\n    Otherwise a new graph is created."}],"description":"Return a graph from a list of edges.","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},"see":[],"async":false,"categories":["convert"]},"draw":{"name":"draw","aliases":["draw","drawing.draw"],"params":[{"name":"G","type":{"type":"NameExpression","name":"jsnx.classes.Graph"},"typeAsHTML":"jsnx.classes.Graph","description":"The graph to draw"},{"name":"config","type":{"type":"NameExpression","name":"Object","optional":true,"nullable":true},"typeAsHTML":"?Object=","description":"A dictionary of configuration parameters."},{"name":"optBind","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"Set to true to automatically update\n    the output upon graph manipulation. Only works for adding nodes or edges\n    for now."}],"description":"Draw graph G with D3.\n\nThis method draws `G` with the provided `options`. If `optBind` is set to\n`true`, changes to the graph structure will automatically update the\nvisualization.\n\nReturns the force layout used to compute the position of the nodes.\n\nThe following options are available:\n\n- element (Element|String): This option is **required**. Specifies the\n  container of the visualization. A string is interpreted as CSS selector.\n- d3 (d3): Use to explicitly pass a reference to D3. If not present, the\n  global variable d3 will be used instead.\n- width (number): The width of the canvas in pixels. Defaults to the width\n  of the container.\n- height (number): The height of the canvas in pixels. Defaults to the\n  height of the container.\n- layoutAttr (Object): Layout options. The default layout is \"force\", so\n  the options size, linkDistance, linkStrength, friction, charge, theta\n  and gravity can be set. For example, setting `{linkDistance: 10}` will call\n  `force.linkDistance(10)`.\n- nodelist (Iterable): An iterable of nodes. If present, only nodes in that\n  list will be drawn.\n- nodeShape (string): The tag name of the SVG element to be used as nodes.\n  Defaults to \"circle\".\n- nodeAttr (Object): The attributes to set on the node SVG element. This\n  object is passed along to D3's `.attr()` method.\n- nodeStyle (Object): The style properties to set on the node SVG element.\n  This object is passed along to D3's `.style()` method.\n- edgeAttr (Object): The attributes to set on an edge SVG element. Edges are\n  represented by SVG path elements.\n- edgeStyle (Object): The style properties to set on the edge SVG element.\n  Note: Even though the edge element is a SVG path element, you cannot set\n  `stroke-width` to set the stroke width. Instead, the value of\n  `stroke-width` is used as maximum value for the edge width.\n- withLabels (boolean): Whether or not to draw node labels. SVG text elements\n  are used for labels.\n- labels (string|Object|function): The node labels to use.\n  If `withLabels` is `true`, but `labels` is not present, defaults to the\n  node itself.\n  If a string is passed, the value of the property of the node data with the\n  same name will be used.\n  If an object is passed, the label is looked up in the object using the node\n  as property name.\n  If a function is passed, it gets called and passed the corresponding D3\n  data object.\n- labelAttr (Object): Like `nodeAttr` but for the label nodes. Labels are\n  represented by SVG text nodes.\n- labelStyle (Object): Like `nodeStyle` but for the label nodes. Labels are\n  represented by SVG text nodes.\n- withEdgeLabels (boolean): See `withLabels`, but for edges.\n- edgeLabels (string|Object|function): See `labels`.\n- edgeLabelAttr (Object): Like `labelAttr`.\n- edgeLabelStyle (Object): Like `labelStyle`.\n- weighted (boolean): Whether the edge width depends on the weight of the\n  edge. The max and min weight are automatically computed. This is a\n  convenience option so that you don't have to compute the edge weights\n  yourself.\n- weights (string|function): Specifies the weight for each edge.\n  If `weighted` is `true` but `weights` is not present, defaults to\n  `\"weight\"`.\n  If a string is passed, the value of the property of the edge data with the\n  same name is used as weight.\n  If a function is passed, it gets called and passed the corresponding D3\n  data object.\n- edgeOffset (number|function): The distance in pixels between the edge start\n  and the node. If not set and `nodeShape` is a `\"circle\"`, the offset will\n  be automatically computed based on the radius.\n  If a different shape for nodes is used it might be necessary to set the\n  offset manually.\n- edgeLabelOffset (number|function): By default edge labels are drawing in\n  in the center of the edge. Can be used to adjust the position.\n- panZoom (Object):\n     - enabled (boolean): Enables panning and zooming of the canvas.\n     - scale (boolean): Whether nodes and labels should keep their size\n       when zooming or not.","returns":{"type":{"type":"NameExpression","name":"d3.layout.force"},"typeAsHTML":"d3.layout.force"},"see":[],"async":false,"categories":["drawing"]},"observe":{"aliases":["observe"],"name":"observe","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"The graph to make observable"}],"description":"Makes a graph observable, i.e. external code can bind event handlers to\nbe notified about changes in the graph (adding or removing nodes or edges).","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"The same graph passed as argument (not a new graph)"},"see":[],"async":false,"categories":[]},"unobserve":{"aliases":["unobserve"],"name":"unobserve","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Removes the properties added to a graph for event handling.","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"The graph passed to the function"},"see":[],"async":false,"categories":[]},"isObservable":{"aliases":["isObservable"],"name":"isObservable","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Tests whether the graph is observable.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"},"see":[],"async":false,"categories":[]},"KeyError":{"name":"KeyError","aliases":["KeyError","exceptions.KeyError"],"isClass":true,"methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"KeyError","computed":false,"params":[{"name":"message"}],"async":false},"categories":["exceptions"]},"JSNetworkXAlgorithmError":{"name":"JSNetworkXAlgorithmError","aliases":["JSNetworkXAlgorithmError","exceptions.JSNetworkXAlgorithmError"],"isClass":true,"description":"Exception for unexpected termination of algorithms.","extends":"JSNetworkXException","methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXAlgorithmError","computed":false,"params":[{"name":"message"}],"async":false},"categories":["exceptions"]},"JSNetworkXError":{"name":"JSNetworkXError","aliases":["JSNetworkXError","exceptions.JSNetworkXError"],"isClass":true,"methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXError","computed":false,"params":[{"name":"message"}],"async":false},"categories":["exceptions"]},"JSNetworkXException":{"name":"JSNetworkXException","aliases":["JSNetworkXException","exceptions.JSNetworkXException"],"isClass":true,"methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXException","computed":false,"params":[{"name":"message"}],"async":false},"categories":["exceptions"]},"JSNetworkXNoPath":{"name":"JSNetworkXNoPath","aliases":["JSNetworkXNoPath","exceptions.JSNetworkXNoPath"],"isClass":true,"description":"Exception for algorithms that should return a path when running\non graphs where such a path does not exist.","extends":"JSNetworkXUnfeasible","methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXNoPath","computed":false,"params":[{"name":"message"}],"async":false},"categories":["exceptions"]},"JSNetworkXUnfeasible":{"name":"JSNetworkXUnfeasible","aliases":["JSNetworkXUnfeasible","exceptions.JSNetworkXUnfeasible"],"isClass":true,"description":"Exception raised by algorithms trying to solve a problem\ninstance that has no feasible solution.","extends":"JSNetworkXAlgorithmError","methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXUnfeasible","computed":false,"params":[{"name":"message"}],"async":false},"categories":["exceptions"]},"fullRaryTree":{"name":"fullRaryTree","aliases":["fullRaryTree","generators.fullRaryTree","generators.classic.fullRaryTree","classic.fullRaryTree"],"params":[{"name":"r","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"branching factor of the tree"},{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"number of nodes in the tree"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"\nUse specified type to construct graph"}],"description":"Creates a full r-ary tree of n vertices.\n\nSometimes called a k-ary, n-ary, or m-ary tree.  \"... all non-leaf\nvertices have exactly r children and all levels are full except\nfor some rightmost position of the bottom level (if a leaf at the\nbottom level is missing, then so are all of the leaves to its\nright.\" (1)\n\n### References\n\n[1] An introduction to data structures and algorithms,\n   James Andrew Storer,  Birkhauser Boston 2001, (page 225).","returns":{"name":"","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"An r-ary tree with n nodes."},"see":[],"async":false,"categories":["generators","classic"]},"balancedTree":{"name":"balancedTree","aliases":["balancedTree","generators.balancedTree","generators.classic.balancedTree","classic.balancedTree"],"params":[{"name":"r","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Branching factor of the tree"},{"name":"h","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Height of the tree"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"\nUse specified type to construct graph"}],"description":"Return the perfectly balanced r-tree of height h.\n\nThis is the rooted tree where all leaves are at distance h from\nthe root. The root has degree r and all other internal nodes have\ndegree r+1.\n\nNode labels are the integers 0 (the root) up to  numberOfNodes - 1.\n\nAlso referred to as a complete r-ary tree.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"completeGraph":{"name":"completeGraph","aliases":["completeGraph","generators.completeGraph","generators.classic.completeGraph","classic.completeGraph"],"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the complete graph `$K_n$` with n nodes.\n\nNode labels are the integers 0 to n-1.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"cycleGraph":{"name":"cycleGraph","aliases":["cycleGraph","generators.cycleGraph","generators.classic.cycleGraph","classic.cycleGraph"],"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the cycle graph C_n over n nodes.\n\n`$C_n$` is the n-path with two end-nodes connected.\n\nNode labels are the integers 0 to n-1\nIf `optCreateUsing` is a DiGraph, the direction is in increasing order.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"emptyGraph":{"name":"emptyGraph","aliases":["emptyGraph","generators.emptyGraph","generators.classic.emptyGraph","classic.emptyGraph"],"params":[{"name":"optN","type":{"type":"NameExpression","name":"number","optional":true,"nullable":true},"typeAsHTML":"?number=","description":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true,"nullable":true},"typeAsHTML":"?Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the empty graph with n nodes and zero edges.\n\nNode labels are the integers 0 to n-1\n\n### Example\n\n```\nvar G = jsnx.emptyGraph(10)\nG.numberOfNodes()\n// 10\nG.numberOfEdges()\n// 0\n```\n\nThe variable `optCreateUsing` should point to a \"graph\"-like object that\nwill be cleaned (nodes and edges will be removed) and refitted as\nan empty \"graph\" with n nodes with integer labels. This capability\nis useful for specifying the class-nature of the resulting empty\n\"graph\" (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.).\n\nThe variable `optCreateUsing` has two main uses:\nFirstly, the variable `optCreateUsing` can be used to create an\nempty digraph, network,etc.  For example,\n\n```\nvar n = 10;\nvar G = jsnx.emptyGraph(n, new jsnx.DiGraph());\n```\n\nwill create an empty digraph on n nodes.\n\nSecondly, one can pass an existing graph (digraph, pseudograph,\netc.) via `optCreateUsing`. For example, if `G` is an existing graph\n(resp. digraph, pseudograph, etc.), then `emptyGraph(n,G)`\nwill empty G (i.e. delete all nodes and edges using `G.clear()` in\nbase) and then add n nodes and zero edges, and return the modified\ngraph (resp. digraph, pseudograph, etc.).","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":"createEmptyCopy","async":false,"categories":["generators","classic"]},"grid2dGraph":{"name":"grid2dGraph","aliases":["grid2dGraph","generators.grid2dGraph","generators.classic.grid2dGraph","classic.grid2dGraph"],"params":[{"name":"rows","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Number of rows"},{"name":"columns","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Number of columns"},{"name":"optPeriodic","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","defaultValue":"false"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","defaultValue":"null"}],"description":"Return the 2d grid graph of mxn nodes,\neach connected to its nearest neighbors.\nOptional argument `optPeriodic` will connect\nboundary nodes via periodic boundary conditions.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"nullGraph":{"name":"nullGraph","aliases":["nullGraph","generators.nullGraph","generators.classic.nullGraph","classic.nullGraph"],"params":[{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the Null graph with no nodes or edges.\n\nSee `emptyGraph` for the use of `optCreateUsing`.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"pathGraph":{"name":"pathGraph","aliases":["pathGraph","generators.pathGraph","generators.classic.pathGraph","classic.pathGraph"],"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and\n    add nodes to."}],"description":"Return the Null graph with no nodes or edges.\n\nSee `emptyGraph` for the use of `optCreateUsing`.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"trivialGraph":{"name":"trivialGraph","aliases":["trivialGraph","generators.trivialGraph","generators.classic.trivialGraph","classic.trivialGraph"],"params":[{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and\n    add nodes to."}],"description":"Return the Trivial graph with one node (with integer label 0) and no edges.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","classic"]},"havelHakimiGraph":{"name":"havelHakimiGraph","aliases":["havelHakimiGraph","generators.havelHakimiGraph","generators.degreeSequence.havelHakimiGraph","degreeSequence.havelHakimiGraph"],"params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"list of integers\n    Each integer corresponds to the degree of a node (need not be sorted)."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"\nReturn graph of this type. The instance will be cleared.\nDirected graphs are not allowed."}],"description":"Return a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm.\n\n### Notes\n\nThe Havel-Hakimi algorithm constructs a simple graph by\nsuccessively connecting the node of highest degree to other nodes\nof highest degree, resorting remaining nodes by degree, and\nrepeating the process. The resulting graph has a high\ndegree-associativity. Nodes are labeled `1,.., degreeSequence.length`,\ncorresponding to their position in `degreeSequence`.\n\nThe basic algorithm is from Hakimi (1) and was generalized by\nKleitman and Wang (2).\n\n### References\n\n[1] Hakimi S.,\n  On Realizability of a Set of Integers as Degrees of the\n  Vertices of a linear Graph. I,\n  Journal of SIAM, 10(3), pp. 496-506 (1962)\n[2] Kleitman D.J. and Wang D.L.\n  Algorithms for Constructing Graphs and Digraphs with Given Valences and\n  Factors,\n  Discrete Mathematics, 6(1), pp. 79-88 (1973)","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"asyncName":"genHavelHakimiGraph","categories":["generators","degreeSequence"]},"genHavelHakimiGraph":{"name":"genHavelHakimiGraph","aliases":["genHavelHakimiGraph","generators.genHavelHakimiGraph","generators.degreeSequence.genHavelHakimiGraph","degreeSequence.genHavelHakimiGraph"],"syncName":"havelHakimiGraph","async":true,"params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","description":"list of integers\n    Each integer corresponds to the degree of a node (need not be sorted)."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"\nReturn graph of this type. The instance will be cleared.\nDirected graphs are not allowed."}],"categories":["generators","degreeSequence"]},"fastGnpRandomGraph":{"name":"fastGnpRandomGraph","aliases":["fastGnpRandomGraph","generators.fastGnpRandomGraph","generators.randomGraphs.fastGnpRandomGraph","randomGraphs.fastGnpRandomGraph"],"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes"},{"name":"p","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Probability for edge creation"},{"name":"optDirected","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"If true return a directed graph","defaultValue":"false"}],"description":"Return a random graph `$G_{n,p}$` (Erdős-Rényi graph, binomial graph).\n\nThe `$G_{n,p}$` graph algorithm chooses each of the `$[n(n-1)]/2$`\n(undirected) or `$n(n-1)$` (directed) possible edges with probability `$p$`.\n\nThis algorithm is `$O(n+m)$` where `$m$` is the expected number of\nedges `$m = p*n*(n-1)/2$`.\n\nIt should be faster than `gnpRandomGraph` when `p` is small and\nthe expected number of edges is small (sparse graph).\n\n### References\n\n[1] Vladimir Batagelj and Ulrik Brandes,\n    \"Efficient generation of large random networks\",\n    Phys. Rev. E, 71, 036113, 2005.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"asyncName":"genFastGnpRandomGraph","categories":["generators","randomGraphs"]},"genFastGnpRandomGraph":{"name":"genFastGnpRandomGraph","aliases":["genFastGnpRandomGraph","generators.genFastGnpRandomGraph","generators.randomGraphs.genFastGnpRandomGraph","randomGraphs.genFastGnpRandomGraph"],"syncName":"fastGnpRandomGraph","async":true,"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes"},{"name":"p","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Probability for edge creation"},{"name":"optDirected","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"If true return a directed graph","defaultValue":"false"}],"categories":["generators","randomGraphs"]},"gnpRandomGraph":{"name":"gnpRandomGraph","aliases":["gnpRandomGraph","generators.gnpRandomGraph","generators.randomGraphs.gnpRandomGraph","randomGraphs.gnpRandomGraph"],"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes"},{"name":"p","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Probability for edge creation"},{"name":"optDirected","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"\nIf true returns a directed graph","defaultValue":"false"}],"description":"Return a random graph `$G_{n,p}$` (Erdős-Rényi graph, binomial graph).\n\nChooses each of the possible edges with probability `p.\n\nThis is also called `binomialGraph` and `erdosRenyiGraph`.\n\nThis is an `$O(n^2)$` algorithm.  For sparse graphs (small `$p$`) see\n`fastGnpRandomGraph for a faster algorithm.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"asyncName":"genGnpRandomGraph","categories":["generators","randomGraphs"]},"genGnpRandomGraph":{"name":"genGnpRandomGraph","aliases":["genGnpRandomGraph","generators.genGnpRandomGraph","generators.randomGraphs.genGnpRandomGraph","randomGraphs.genGnpRandomGraph"],"syncName":"gnpRandomGraph","async":true,"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"The number of nodes"},{"name":"p","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","description":"Probability for edge creation"},{"name":"optDirected","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","description":"\nIf true returns a directed graph","defaultValue":"false"}],"categories":["generators","randomGraphs"]},"binomialGraph":{"name":"binomialGraph","aliases":["binomialGraph","generators.binomialGraph","generators.randomGraphs.binomialGraph","randomGraphs.binomialGraph"],"params":[{"name":"n"},{"name":"p"},{"name":"optDirected"}],"description":"","see":[],"aliasFor":"gnpRandomGraph","async":false,"asyncName":"genBinomialGraph","categories":["generators","randomGraphs"]},"genBinomialGraph":{"name":"genBinomialGraph","aliases":["genBinomialGraph","generators.genBinomialGraph","generators.randomGraphs.genBinomialGraph","randomGraphs.genBinomialGraph"],"syncName":"binomialGraph","async":true,"params":[{"name":"n"},{"name":"p"},{"name":"optDirected"}],"categories":["generators","randomGraphs"]},"erdosRenyiGraph":{"name":"erdosRenyiGraph","aliases":["erdosRenyiGraph","generators.erdosRenyiGraph","generators.randomGraphs.erdosRenyiGraph","randomGraphs.erdosRenyiGraph"],"params":[{"name":"n"},{"name":"p"},{"name":"optDirected"}],"description":"","see":[],"aliasFor":"gnpRandomGraph","async":false,"asyncName":"genErdosRenyiGraph","categories":["generators","randomGraphs"]},"genErdosRenyiGraph":{"name":"genErdosRenyiGraph","aliases":["genErdosRenyiGraph","generators.genErdosRenyiGraph","generators.randomGraphs.genErdosRenyiGraph","randomGraphs.genErdosRenyiGraph"],"syncName":"erdosRenyiGraph","async":true,"params":[{"name":"n"},{"name":"p"},{"name":"optDirected"}],"categories":["generators","randomGraphs"]},"makeSmallUndirectedGraph":{"name":"makeSmallUndirectedGraph","aliases":["makeSmallUndirectedGraph","generators.makeSmallUndirectedGraph","generators.small.makeSmallUndirectedGraph","small.makeSmallUndirectedGraph"],"params":[{"name":"graphDescription","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"\nDescription of the graph to create in the form `{type, name, n, list}`."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return a small undirected graph described by `graphDescription`.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":"makeSmallGraph.","async":false,"categories":["generators","small"]},"makeSmallGraph":{"name":"makeSmallGraph","aliases":["makeSmallGraph","generators.makeSmallGraph","generators.small.makeSmallGraph","small.makeSmallGraph"],"params":[{"name":"graphDescription","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","description":"\nDescription of the graph to create in the form `{type, name, n, list}`."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the small graph described by graph_description.\n\n`graphDescription` is a list of the form `{type, name, n, list}`.\n\nHere `ltype` is one of `\"adjacencylist\"` or `\"edgelist\"`,\n`name` is the name of the graph and `n` the number of nodes.\nThis constructs a graph of `n` nodes with integer labels 0,..,n-1.\n\nIf `ltype=\"adjacencylist\"` then `xlist` is an adjacency list\nwith exactly `n` entries, in with the `j`'th entry (which can be empty)\nspecifies the nodes connected to vertex `j`.\n\nE.g. the \"square\" graph `$C_4$` can be obtained by\n\n```\nvar G = makeSmallGraph({\n  type: \"adjacencylist\",\n  name: \"C_4\",\n  n: 4,\n  list: [[2,4],[1,3],[2,4],[1,3]]\n});\n```\n\nor, since we do not need to add edges twice,\n\n```\nvar G = makeSmallGraph({\n  type: \"adjacencylist\",\n  name: \"C_4\",\n  n: 4,\n  list: [[2,4],[3],[4],[]]]\n});\n```\n\nIf `ltype=\"edgelist\"` then `xlist` is an edge list written as\n`[[v1,w2],[v2,w2],...,[vk,wk]]`, where `vj` and `wj` integers in the range\n1,..,n\n\nE.g. the \"square\" graph `$C_4$` can be obtained by\n\n```\nvar G = makeSmallGraph({\n  type: \"edgelist\",\n  name: \"C_4\",\n  n: 4,\n  list: [[1,2],[3,4],[2,3],[4,1]]]\n});\n```\n\nUse the `optCreateUsing` argument to choose the graph class/type.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","small"]},"bullGraph":{"name":"bullGraph","aliases":["bullGraph","generators.bullGraph","generators.small.bullGraph","small.bullGraph"],"params":[{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the Bull graph.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","small"]},"krackhardtKiteGraph":{"name":"krackhardtKiteGraph","aliases":["krackhardtKiteGraph","generators.krackhardtKiteGraph","generators.small.krackhardtKiteGraph","small.krackhardtKiteGraph"],"params":[{"name":"opt_create_using","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","description":"Graph instance to empty and add nodes to."}],"description":"Return the Krackhardt Kite Social Network.\n\nA 10 actor social network introduced by David Krackhardt\nto illustrate: degree, betweenness, centrality, closeness, etc.\nThe traditional labeling is:\nAndre=1, Beverley=2, Carol=3, Diane=4,\nEd=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","small"]},"karateClubGraph":{"name":"karateClubGraph","aliases":["karateClubGraph","generators.karateClubGraph","generators.social.karateClubGraph","social.karateClubGraph"],"params":[],"description":"Return Zachary's Karate club graph.\n\n### References\n\n[1] Zachary W.\n    An information flow model for conflict and fission in small groups.\n    Journal of Anthropological Research, 33, 452-473, (1977).\n\n[2] Data file from:\n    <http://vlado.fmf.uni-lj.si/pub/networks/data/Ucinet/UciData.htm>","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","social"]},"davisSouthernWomenGraph":{"name":"davisSouthernWomenGraph","aliases":["davisSouthernWomenGraph","generators.davisSouthernWomenGraph","generators.social.davisSouthernWomenGraph","social.davisSouthernWomenGraph"],"params":[],"description":"Return Davis Southern women social network.\n\nThis is a bipartite graph.\n\n### References\n\n[1] A. Davis, Gardner, B. B., Gardner, M. R., 1941. Deep South.\nUniversity of Chicago Press, Chicago, IL.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","social"]},"florentineFamiliesGraph":{"name":"florentineFamiliesGraph","aliases":["florentineFamiliesGraph","generators.florentineFamiliesGraph","generators.social.florentineFamiliesGraph","social.florentineFamiliesGraph"],"params":[],"description":"Return Florentine families graph.\n\n### References\n\n[1] Ronald L. Breiger and Philippa E. Pattison\nCumulated social roles: The duality of persons and their algebras,1\nSocial Networks, Volume 8, Issue 3, September 1986, Pages 215-256","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["generators","social"]},"relabelNodes":{"name":"relabelNodes","aliases":["relabelNodes","relabel.relabelNodes"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A JSNetworkX graph"},{"name":"mapping","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"Map"},{"type":"FunctionType","params":[{"type":"NameExpression","name":"Node"}],"result":{"type":"NameExpression","name":"Node"}}]},"typeAsHTML":"(Object|Map|function(Node): Node)","description":"\nA dictionary with the old labels as keys and new labels as values.\nA partial mapping is allowed."},{"name":"optCopy","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","description":"\nIf `true` return a copy or if `false` relabel the nodes in place.","defaultValue":"true"}],"description":"Relabel the nodes of the graph G.\n\n### Examples\n\n```\nvar G = jsnx.pathGraph(3);  // nodes 0-1-2\nvar mapping = {0: 'a', 1: 'b', 2: 'c'};\n// var mapping = new Map([[0, 'a'], [1, 'b'], [2, 'c']]);\nvar H = jsnx.relabelNodes(G, mapping);\nH.nodes();\n// ['a', 'b', 'c']\n```\n\nPartial in-place mapping\n\n```\nvar G = jsnx.pathGraph(3);  // nodes 0-1-2\nvar mapping = {0: 'a', 1: 'b'};\n// var mapping = new Map([[0, 'a'], [1, 'b']]);\nvar H = jsnx.relabelNodes(G, mapping, false);\nH.nodes();\n// [2, 'b', 'c']\n```\n\nMapping as function:\n\n```\nvar G = jsnx.pathGraph(3);\nvar H = jsnx.relabelNodes(G, x => Math.pow(x, 2));\nH.nodes()\n// [0, 1, 4]\n```\n\n### Notes\n\nOnly the nodes specified in the mapping will be relabeled.\n\nThe setting `copy=false` modifies the graph in place.\nThis is not always possible if the mapping is circular.\nIn that case use copy=true.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":"#convertNodeLabelsToIntegers","async":false,"categories":["relabel"]},"convertNodeLabelsToIntegers":{"name":"convertNodeLabelsToIntegers","aliases":["convertNodeLabelsToIntegers","relabel.convertNodeLabelsToIntegers"],"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","description":"A JSNetworkX graph"},{"name":"optFirstLabel","type":{"type":"NameExpression","name":"number","optional":true,"nullable":true},"typeAsHTML":"?number=","description":"\nAn integer specifying the offset in numbering nodes.\nThe n new integer labels are numbered firstLabel, ..., n-1+firstLabel.","defaultValue":"0"},{"name":"optOrdering","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","description":"\n- \"default\" : inherit node ordering from `G.nodes()`\n- \"sorted\"  : inherit node ordering from `G.nodes().sort()`\n- \"increasing degree\" : nodes are sorted by increasing degree\n- \"decreasing degree\" : nodes are sorted by decreasing degree","defaultValue":"'default'"},{"name":"optDiscardOldLabels","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","description":"\nIf true discard old labels. If false, create a node attribute\n'oldLabel' to hold the old labels.","defaultValue":"true"}],"description":"Return a copy of G node labels replaced with integers.\n\n### Notes\n\nNode and edge attribute data are copied to the new (relabeled) graph.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},"see":[],"async":false,"categories":["relabel"]}}