// @see https://babeljs.io/en/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=FDD0oAgZQFQQQEowgWggBQE4HsDmmBDAWwDoArAZ2AGNsA7CgFwgBsBLOgUxmykcw64IAXlYdOIgHwQA3sACQmTowCumOmK4lsABwgBqCAHJjBzZxIFMuCgG0ADAF0zJk4YAU7LVZu2AjM4APoHGRgCUANzAAL5RNPRMGDj4xCIQ7jIQOsmERAA0EBxMmCrUjGz0ENFpMtFhUrIKtAzMOADuFGnZeLkkRAQ67p7iBWz1wtJy8vLNiQRlbABuEqJsIsKrLSUL9FHTs8zz5csA-tQsBBSdokdLEgD8xrfLJgBcoXuKymoa7grTAB5-BBzpcKAA5YicYQyZ6cM4XK7RST_QGMAAmIMREKhMLhCLByNR01hC2WEEeAIARhAmABPFjQmSZWgsbCYd5Gfo4egmaLIgBUANAVOknKM0WJwoxKOmaPRxJm2MhRCZ-NBSMV9MZMMyjE4AA9GHB2Lg6JyBLgABaMIwFHQEdHowQINjWxicvycIh8yVy-Sy_2k44PCDUyQyNjRYWiiDvKNS0AyqUYrFglVqsnwjUUZEyLzcXj8QTDLhhaNJ9GB-TSzCByIKOp7JSqdTpf4A52LWmMBlMzIAM0ZBoA4u13n4qkS5UCCFTGdWa4wqdh0XSI-1c9KV2vq9K5wvUZ2lovI1tSuVKtJuilSIy6LhGFbUBBJ48_v6azTtf2Qdg2Ryxj4JwnB0L6kgACL0JwMaLvU7x0CoLAsH6gKgF2gbChhCgNrEYCQAAouCEEvlgPTEOQVD4dA8BIC-CCcLgbBMJwmAUJR8QtBADFMSxbFpBkEBKLx-r8dUoi1OMkxNAkzCZAQBRUgU1AFJi4lCYxzGiRQzbfG2H41thM5IT2fa6hA3JMeaED2PajrOg-AAynADh6xh-PYOgGuBUrsJIBDvLCFZ-b5bCSFSgVUsFYWhZI1CBdQ0WLgCfnooF6JJUeoBIZh6EnjhUR4eAEBESRaA8VprHsZQIDFbAiDIGgABCSgEAA1gA8nQHE5hALWcO1XUQIa-p0OinQMUcJAAMLYEQOjQXQckyeeZTsu43Q6BQ9RTPIFAqDorEbTgW0NtMT7MX0dIMQOaSTWUJDUK1-o3e4Z2SjJ82LYwEFsOiACy2AqEtb2NOdVqXUQ10uY9ahKEt2h0NQVoEA-KzDQ0u3yBd7GbexFDKBBnCLGw1CcP1g10O4ONXTdsOYPDjAkIsBAsConBnfIeFcyAXxjUdO3_C2PztjOFxUpwLCLhTbUQPQ7wAhwOgqK0LkwjTUM3dUoB7qA4uS_WeySpKxWlS-MtdRx1H1XRaCzUtOAsNVVAHH1KuMJUoiCSxOgFD7FDKRDLDovDVQ1HUmMrYkA4aF7Uk9pwgz-w2CjC221Lu5U9DTew1BtTCMd5sjbDB_DFZUpndCSIVcSu_b_D_tcWQndc0lfK2vwdkZgJdqZOrMhA-pGiabrWUYZNLaxPn-gCTWVwnOgwnjJAlHQACqS0lzLyKAG2kwpz4wHtV1l3eGflM8H0fC9Ly3JA-9U_swn407-gAZI-nxoZf9DJd_Gg-zfXQ-N9Q6AfiAigT97AvzlIAayJEx_1_vPABMhl73wXhAmQHkoGLnkIATaJ4GV11t3LC59cJRFNsRF89dHbO1qpAG2jUIBExJmTK2oABQCmABAAUEAAAG1AdB0ggAaCAdJeEQDOLoNgnAKAnD4QacR7hOBsCfKxCAqNCiT1wGo9kg8rQSBOCzNm8I5a3QIBpESrF6gcA9hYyqmA-FiJIFwnhvCODUGEeIk47jWoE1kXoiQRj2amLsXxeR4iqRCOgs47hfD0ScA8QoiR8SnoDT8XI1REAgkSGwLdYS9jwkQEiXLLQLi-FkDoAAL2EaIrxZAVDzX8bYjRRR-AXgqBoXhYj1FtAIEIja2AKAqLuBZAaDAIADnZL0zA6IIgQC4LgAgIZRmo06FSeYbVpnojCIpFWJSWBCLYLdXhSTmISLoNgZglTWLYBODEzhsTeGMFwCwTxEiPa4BeTIjJ-jNHFHaZUE54iCC9P6QtGxgh1HMFadsS84z2BtQkLwiplTxHomwDI94C0hnLNVKsiZUyrCzPmYxJZIy8XjPWXnLZYRXhlIgC-AAYrok40EUA-AaaBRgciYUAoYAUNxSMIkJLmjIuJCTeEFFRpiVmrzLn6IcWyjlqolp_LaTsSlIrVR8Pcbw-5DKmUssYG0bA7LrCcqWjy1acKA7lKqcK2gqpOj8MEZK9RY11HITlqohxxrTW8o1WsrVSKUV6vpS-GAvzlVcs6Lk9Rg88BfMxAGuF6ilDnMueogcA4En6nRHc8NaAACSZiNBLP1PNaFnR-jxITQmz5jJ3VqthR0uWKshm1syTeXIBQTgXIug-CAKMdCHQYAW2JDLi23Q-S8yF3R0SlDFRo7xdAjF_WbXyuRwxEV8IEUIycAAmXh9RpVNvLd6HQVbWBLLUTWiQtjDQJJVvelG0LrUdIFRQNqbA9AqLVQNdEYaJ0vhLXw55LBxEzsZJ0bxjACYsAHFuyZDjDTEB0IyUYxyCDiLObw-wbqnkvPUeIk1SFMSMB8MoQocHJalsxBLR1SL3HEZ2QEjS-0WDlEHSm1tZz-3DQNE-vNEBgblFeZkrgRpB5sG1X-s5rVkacHRPc0AIBXYwA6iOEcjkCInBgAgOA4IoCMo6ggf6UAagKHcZyFJdoFApM5O4uz2MXmOaRs5lFnI93Ob3ZyFFdm8KcUSAANTgI5ItEETgdXQBZ0QHUqRkFzSQRFdIKDuA01pnTemDNGZM2ZqAKdXYOjYpwRy4g0gFkjgyxkzBitwYq-IO-6GVHuAAEQQFaw2BlRz0gAEJQvhci9FqAJB3Fs3iWlurdgnBhEFgavR7QSVtBKgzdavCi2rtZuu3QWQwRKfeK1gAJCgqwcGHCOGiO1jg5gOvHYLJd49UQGUfQZa7fJfEm62FawQVrBRWtUl-x16ggPWvola44J7f4uI-E-xDrhhRbruF6-97So2kbjZkRtU7dgAizcaPNt7IKTg-C6Nj_wcP5tTfJ6TkrG3GBY8wGdgIBQPJdYNT19w4IGkS0wKNnE4IGdM8cHjuQ82GVPkW1wZbBFVuYD-GLg163NvsExIhIgPOICQBR2oy4aaVC4BVbVvbaVbsyEIG0Yn1hLuaJu0d_M4gHvw_m2z578OXtppsCQZWFArSC5x8LuI3XEdU4Pc4XrohEJetfq_CAyPNIfbR-cFQE2_e2FDyLp3UPEjm8t0IUQIeKcGoLzTgmdPU-h5Z_YFO82Odc_V6xPnkIBcF4zwriX2BltS5WzgOXmf5tK7Xar7naitfx9EuozoVh9eG921cfbpuc8-Gt9dyrdv7utd4X3iALuqhu5AEH9Ixfw_zKQiwObBqYde5UD78vAe9_w7ThoTIugsVk6cFK6wnQ8KBfYQ8nhRauR5lM1WpkIhEUYxovAhAmAb0OtMl7pmBQVWsykGMCBr8X0zlHUFouBVV0UZEwJmA2oLlls2h9ENAVFOg8YQRwDtF9UoBsAIAi0hJgY-FkMyY14dB0Qb1xFiZWIhFyhtUu0chUhkZUZtF2IylAA-DcAHZdwAWAJAAhMkAHg_lxVTXqZhUmCQEaUCcabiAaB6WaL6bA5aGYWSWFdaPGQWaYfaQ6OXcwz4V2LGbtVIUQWwRwPIVEaAxnQQE4bXfiCSdRd4AAdkUneFshBBCNUhCKqDcLlA8K41wBXX-Q1TSFsn-HUjxjiGmGKhzmgjYysEIFSwgDaAkAdCuE0X-BpkcKIDSAACkoAOpwQvcrACZ3Baj6i75iwHwjk6RjpyIiBZtPgaYfCm5WiGjitmiRj2iBBOiBxujYivChj-jeZ5A6oCByRkN2NlBOgLhRJyiIZgFTt5ix8qo0g5iHxvCji2IBi9j2iDizjKiughCiAMjsZrieNPYexbj4i3i6ArjLpoD9RLM5QqRWpOox5nNzpeBlBOQCBwT5BskeAoBlAeAJwD1oiuYjZeYlACZmA45I5wZLohiai6jRimjOAWjiTJjBAujqZrjTj4iFjOYKjHiiS2ixiySJjigqSZiaS_iKNPC7jHjFj8T2Jvjkjfj2JWDOB2DOD9Q3ojYMjV4BIfCTgPYThsgbE0gjAYT45doasbtRAmTejbAaZvi4d_gSCS4JBSwOYwZpg9Tn9fYPcv8GsuBnjljIAEBmDMldBaB4lUQcZbBdBHBLAR0DkeTbUYcU45RKsDTrjKjjTXj316A4dpgPpphH89ECSLi7BlTVT1SloUzAtFBgYN4xMZYBIdT_g9SYzMzcZHiEzLpTTnj2FhoKAvBGAUBnQKADwJABRVNpgLTG1rSLD9hZJZB1FFJlJVIw5YyszLFLjURXY1hZyRSkyfiljsZMAhEsZ5AOdiZWZwybj9QSBgSBpQSM9PwaZJTpSb05TFRTz2pP4eY5RqhqAllkZ0gbTagNz7S5ZHSYcZzzA3TipPSNBvSdBfTOB_S9jAydBgyBh0NuicYP8bAoy7TysVyvd6yTS1yUznzlieEZF2yUBQIezuFVNdjLpryODbz3oMifYBJY5XxKzph1jPAqNlybI5k1gAR5luL9B9ARzjCuIHSULnTML4ycLEi4UzS5QQKvTfkfTVwoK5QAygyQzELwyxLOY0yXiqL2Q2CaLZS6LeZtFGBgtWZ2YOpbpRAREJhbSMzexDo407KNhjBOSHwTBHhBjszbADRnB3gDR5TeZf8FBYkOoILlKqB5ByKQrIBZpBEXxaAdBpFnUkklEVEFUm0bFGIdFfVflskQlzEfDrElp6CfDHEw0ZhEqvYDQCg6QWK9LVzpKOkBLmzIANtB8N0NU_Zv0dB_gOcnLOA40hFw9RAjAPLcBwhbT24fhPhdKfL5y7A6RnBMKzKLLjFrL3ADQ0LHLrihjgqFBioNtUlLgJA0AfE0kxVMlCq40KqgUikolSldykY0g7K24mqV5fL_KDBRA_BnipL1U4U2qli9q5z7EdJGwMjioiZTqCYXwUlfFrqCrLKck8kLjClilol7MEk3q8TPqhi_LnAUA_qAbEyWr6AQahY9IwL9rszDr3SIBqiGk9A0B6lGk60Wk1zKqek-lD9BlhlyQKVOhkMtk5kFkyUhaxk1kNkaVdlmB6ADkEdCk-NM1rkcBnF5AUUBI6rRFGq7LaySB1rUatqdrPghE1rlANqrKBx3AGrniOdXLRAq8ZripI1QIIB6lEgiBsA1jCUZkJ8gDMB-gWBoLGy1yQbUzhonYJAsZioOofU2hmJOACh2a9AgYHFviw7mqgbW19BRA6R5rQaabDaDqoa4qIAeAG0VLwM8b7LdoDaaZjbNrbazali9TviVTbkfbnQZi0hAaW1KhDAgqBrEdDTbxbBO7VSe6ujhcZq9TqA4YuVWU9AJL6yp7u7VxZ7tAdBP5x7chJ61yu6TgZ6ZjgydthBiQMttNdN9NDNjNTNzNbBF6GZl6gyi7KKc7B66BI6izsS1CyYLYmKHzQT8aaZsS-BbzMgQGhomxy6FBwD0RGRETGAeBppqD0YVgPq9SPYUG0gLA-SzLmZUbPhBrIScS3KjA2BpqsZcGqNxrvijB5ro74ayG8GNhxqWAaH_TyHNSCwmHUiljwHlBIHZS9ReG4H0TeZEHGRrbOB0HRDMGwHaSRGKMxGslUaESkTsB3gCHKMmZCrJGiyZHOAUGeAKz8b7CE0UH3hsSeACh4TyHzH1JwG1HOAHbEc7H6COHjB-GhLqyMLdsSsysuB3BHGzHsBOZPrJLybc7kyXT3HUiWHY7FyxzCr89SSy9wntHK8ona9h9edmIm8wnUaLy5RH9P5dLdyx6YKvGw83LgZ4kBxxBtkZqmrbA6m0hslKmNzBq6alqOntH6nRBGmXIWmhKCbfLOnRBunURUIFrrjqKZSySTLU4tCBYHKS6DIax4CSBGVCADcuVkpT5pgUGZBXBUIZwlYVZFQ9pex-5Mgk70QnxOQABOb0X0W57ODB9Wa4kxiJhRtGS5uUbJX53km9EgOhxgYF5YiMC5xUGEeFz8RWOgZWRgW5n8cyJ5l54wd5n0KcL5ugQF7RMF9iExuR4lzgGFuE1G0lo8iwbJ1B7AGFnWRUDOQ-egDF-5_sW5-QSZJaKANga5T0AAZi8lhP9ALAAAllF3RRXxW0TPwHQnRBBOQD0FXeXWR2QLRsA6RWZ5x2YJXUzqXs5c584ZBQZ7KaZ_ntG3oYWcEawKAHQq5AAUcmFCddRkkAUOgGUDZZFEIUTBOePG7BzAzGEFB2JnUNaxwWDb7l_CHENDHA73eAPSnAdYBAqg-1CW0jpaGO1nTeBM13TaAdpEJkjcAZBK6jpf_vLfJkrboHzb9ZOZrDIlvFucqLpcqOpe-Lpe-JZZREVBkAHr5QgGkH3oonvEfGfDQDfBPy9XeG2ZnGoUbl5eQVccTmpeLPXk3hYBllzZLJ3e3ludZc_HLEDfPhnArg5f_m5fMn5cYEFeFfcg-anBKRzlJnNZ8uxOgWmAYmxMTCvaPl1l2f2YIEOaWkNkbBiDoRKkoTQAAYsBqiCzfWGVZhOBlPMVEBdSEXMSpGABSSKRoESvMQVD3RsnUSI6ERpGoGAGYwIHw9xpo-1o8RQAPQY48QVG1sxBQAAFZ2PCOyPqPKOQQIAFQCOFRmMmOqlRPUA2Pa6aOyOUA_AAA2EEYAbWycBTxK1515tT7WgIgI0T2j16-j5jTj6T7jtjyT9T6Tljnj3hWubECAOAEdATUabQ3Z_QrArlfHLPIGswluCwqwo6WwhQGmDD84mynQqaU6l6FyO8z6_49GKYBlDDhCU_aIhlVed4AcVmAmTL0TpZAgGXHvA7JAqR13eHNk1t3IOAMaUCix-uhQPUiL4oNIPgKY3AQ8iLpQAcemRmYh4xMISFgQIgBLjnXrVr_gCw8XFRh9txwSDDkr7VjrAiStIRe4kogmZNbqdrSRrLmmjE5rqjCLvItIKb3nJ19genVrAAHToE6z2Fdgw7SBcOho9OYOv0hXWLZB21aQAxCV4X6B0HEQoHoMYLfI0DfMYA_NYh72iv4G3LCoJQcXYuhTFMKDDEK4o0t150nafH4sEttIw6vxvzZJCbJNO4ZknuFzOldy5hBHfOfCURm8NogYW8yCW9l10chaLE69Bn240g7iO8ZtAyKLTQkAVRTsKMl9WIkHMS6ow7C7m9EbJJS-x4UmR-y8HhKBUrgee0Dz_AMK5V-gBiBhBgsPC6K8i_665UG-CU2FQ5YHQ6K8h3d3hniTlwsIm9cYhdXlZ4zIMmDcDAZQBB0EkAIknnyuKOZOucYD9kTisBvXoyESlwLAoFeGFHD_-FD6Hj5IGlRE3HDZU_K9HKdnDYABZlPS-vgBw6WeuXJLnTWP2YRLWx2VeOeNflvAJI9Xk6hUIGUT2YqwxT52Wr5m-85W_44KjSSaviA6v0RQK7XqwGUGu5-iAspAOf5UQh3aS3GSAuee8KRRZphQ-9BMWB4tXAJWslAwc03d_wXjzD_2QKxs-5R4I52UIc-ww8pFhcojIGU70TEiXQBAIdm4vRatvvww75s3e0HZDkJGwCXICIjIGfKIHRSL1DcRtZQMgO9BcomodIItOiHcBGAeQtoBsPAQggdR_oX1fmHLgBAuc9AOsAoKQJwGG4GwQAA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2016%2Creact%2Cstage-2&prettier=false&targets=&version=7.7.4&externalPlugins=

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// START - Program.js
const lineToString = line => {
  return line.op + ' ' + line.args[0] + ' ' + (line.args[1] || '');
};

const Program = ({
  program,
  instruction
} = {}) => {
  const rows = program.map((line, i) => {
    const active = i === instruction;
    const active_class = active ? 'active' : '';
    return React.createElement("tr", {
      className: active_class
    }, React.createElement("td", {
      className: active_class
    }, active ? React.createElement("b", {
      style: {
        color: 'maroon'
      }
    }, "*") : ''), React.createElement("td", {
      className: active_class,
      style: {
        textAlign: 'right',
        paddingRight: '1em'
      }
    }, active ? React.createElement("b", null, i) : i), React.createElement("td", {
      className: active_class
    }, lineToString(line)));
  });
  return React.createElement("div", {
    style: {
      flexGrow: 1
    }
  }, React.createElement("table", null, React.createElement("tbody", null, rows)), React.createElement("div", null, instruction > program.length - 1 ? React.createElement("b", {
    style: {
      color: 'green'
    }
  }, "Done") : null));
}; // END - Program.js
// START - Registers.js


const Registers = ({
  registers
} = {}) => {
  const {
    a,
    b,
    c,
    d
  } = registers;
  return React.createElement("div", null, "Registers:", React.createElement("ul", {
    style: {
      margin: 0,
      paddingLeft: '10px'
    }
  }, React.createElement("li", null, "a: ", a), React.createElement("li", null, "b: ", b), React.createElement("li", null, "c: ", c), React.createElement("li", null, "d: ", d)));
}; // END - Registers.js
// START - BreakOn.js


class BreakOn extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }

  componentDidMount() {
    this.myRef.current.onchange = e => {
      this.props.setDeviceBreakOn(this.myRef.current.value);
    };
  }

  render() {
    return React.createElement("label", null, "Break on: ", React.createElement("input", {
      ref: this.myRef
    }));
  }

} // END - BreakOn.js
// START - Controls.js


const Button = ({
  step,
  steps,
  children
} = {}) => {
  const fn = () => step(steps);

  return React.createElement("button", {
    onClick: fn
  }, children);
};

const Controls = props => {
  return React.createElement("div", null, React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement(Button, {
    step: props.runUntilBreak
  }, "\u25B6")), React.createElement("div", null, React.createElement(Button, {
    step: props.step,
    steps: 1
  }, ">"), React.createElement(Button, {
    step: props.step,
    steps: 10
  }, "\u226B"), React.createElement(Button, {
    step: props.step,
    steps: 100
  }, "\u22D9")));
}; // END - Controls.js
// START - Device.js

/**
 * `cpy x y` _copies_ `x` (either an integer or the _value_ of a register) into register `y`.
 * `inc x` _increases_ the value of register `x` by one.
 * `dec x` _decreases_ the value of register `x` by one.
 * `jnz x y` _jumps_ to an instruction `y` away (positive means forward; negative means backward), but only if `x` is _not zero_.
 *
 * `tgl x` _toggles_ the instruction `x` away (pointing at instructions like `jnz` does: positive means forward; negative means backward):
 *   - For _one-argument_ instructions, `inc` becomes `dec`, and all other one-argument instructions become `inc`.
 *   - For _two-argument_ instructions, `jnz` becomes `cpy`, and all other two-instructions become `jnz`.
 *   - The arguments of a toggled instruction are _not affected_.
 *   - If an attempt is made to toggle an instruction outside the program, _nothing happens_.
 *   - If toggling produces an _invalid instruction_ (like `cpy 1 2`) and an attempt is later made to execute that instruction, `skip it instead`.
 *   - If `tgl` toggles _itself_ (for example, if `a` is `0`, `tgl a` would target itself and become `inc a`), the resulting instruction is not executed until the next time it is reached.
 */


const TOGGLE_TRANSFORMS = {
  inc: 'dec',
  dec: 'inc',
  tgl: 'inc',
  jnz: 'cpy',
  cpy: 'jnz'
};
const VALID_OPS = Object.keys(TOGGLE_TRANSFORMS);

const parseLine = line => {
  let parts = line.split(" ");

  if (!VALID_OPS.includes(parts[0])) {
    throw new Error(`Invalid op passed: "${parts[0]}" in line "${line}"`);
  }

  const registers = ["a", "b", "c", "d"];
  const args = [];

  if (!registers.includes(parts[1])) {
    const raw_arg = parts[1];
    parts[1] = parseInt(parts[1], 10);

    if (Number.isNaN(parts[1])) {
      throw new Error(`Invalid number / register as arugment passed: "${raw_arg}" in line "${line}"`);
    }
  }

  args.push(parts[1]);

  if (parts[2] != null && !registers.includes(parts[2])) {
    const raw_arg = parts[2];
    parts[2] = parseInt(parts[2], 10);

    if (Number.isNaN(parts[2])) {
      throw new Error(`Invalid number / register as arugment passed: "${raw_arg}" in line "${line}"`);
    }
  }

  if (parts[2] != null) {
    args.push(parts[2]);
  }

  return {
    op: parts[0],
    args
  };
};
/**
 * I'm not really handling state "the React way"
 * because this component doesn't know when its props change.
 * So I run `forceUpdate` every time the program changes.
 * 🤷‍♂️
 */


class Device extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "reset", () => {
      this.registers = JSON.parse(JSON.stringify(this.starting_registers));
      this.program = JSON.parse(JSON.stringify(this.starting_program));
      this.instruction = 0;
      this.forceUpdate();
    });

    _defineProperty(this, "run", (register_to_print = 'a') => {
      let line = this.program[this.instruction];

      while (line) {
        let {
          op,
          args
        } = line; // Run the opcode

        this[op].apply(this, args);
        line = this.program[this.instruction];
      }

      return this.registers[register_to_print];
    });

    _defineProperty(this, "runUntilBreak", () => {
      let line = this.program[this.instruction];
      /* eslint-disable */

      while (line) {
        const {
          a,
          b,
          c,
          d
        } = this.registers;
        const i = this.instruction;

        try {
          if (eval(this.state.breakOn)) {
            this.forceUpdate();
            break;
          }
        } catch (e) {}

        let {
          op,
          args
        } = line; // Run the opcode

        this[op].apply(this, args);
        line = this.program[this.instruction];
      }
      /* eslint-enable */


      this.forceUpdate();
    });

    _defineProperty(this, "step", (n = 1) => {
      for (let i = 0; i < n; i++) {
        const {
          op,
          args
        } = this.program[this.instruction]; // Run the opcode

        this[op].apply(this, args);
      }

      this.forceUpdate();
    });

    _defineProperty(this, "getValueOf", x => {
      return typeof x === 'string' ? this.registers[x] : x;
    });

    _defineProperty(this, "cpy", (x, y) => {
      this.instruction++; // Invalid instruction, skip

      if (typeof y !== 'string') {
        return;
      }

      this.registers[y] = this.getValueOf(x);
      return this.registers;
    });

    _defineProperty(this, "inc", x => {
      this.registers[x] += 1;
      this.instruction++;
      return this.registers;
    });

    _defineProperty(this, "dec", x => {
      this.registers[x] -= 1;
      this.instruction++;
      return this.registers;
    });

    _defineProperty(this, "jnz", (x, y) => {
      x = this.getValueOf(x);
      y = this.getValueOf(y);

      if (x === 0) {
        // Then just move forward as normal
        this.instruction++;
      } else {
        // Otherwise, jump our instruction
        this.instruction += y;
      }

      return this.registers;
    });

    _defineProperty(this, "tgl", x => {
      x = this.getValueOf(x);
      let instruction_to_modify = this.instruction + x;

      if (this.program[instruction_to_modify]) {
        let current_op = this.program[instruction_to_modify].op;
        this.program[instruction_to_modify].op = TOGGLE_TRANSFORMS[current_op];
      }

      this.instruction++;
    });

    _defineProperty(this, "setDeviceBreakOn", breakOn => {
      this.setState({
        breakOn
      });
    });

    _defineProperty(this, "handleSetToChange", e => {
      let toSet = e.target.value;

      if (toSet === 'i') {
        toSet = 'instruction';
      } else if (toSet === 'l') {
        toSet = 'line';
      }

      this.setState({
        toSet
      });
    });

    _defineProperty(this, "handleValueChange", e => {
      this.setState({
        valueToSetTo: e.target.value
      });
    });

    _defineProperty(this, "handleSetTo", () => {
      const {
        toSet: setTo,
        valueToSetTo
      } = this.state;

      if (setTo === 'line') {
        let line = parseLine(valueToSetTo);
        this.program[this.instruction] = line;
      } else {
        const value = parseInt(valueToSetTo, 10);

        if (Number.isNaN(value)) {
          return;
        }

        if (this[setTo] !== undefined) {
          this[setTo] = value;
        }

        if (this.registers[setTo] !== undefined) {
          this.registers[setTo] = value;
        }
      }

      this.forceUpdate();
    });

    const {
      program = [],
      starting_registers = {
        a: 7,
        b: 0,
        c: 0,
        d: 0
      },
      starting_instruction = 0
    } = props; // Clone the arrays we pass in

    this.program = JSON.parse(JSON.stringify(program));
    this.registers = JSON.parse(JSON.stringify(starting_registers)); // Save for resets later

    this.starting_registers = starting_registers;
    this.starting_program = program;
    this.instruction = starting_instruction;
    this.state = {
      breakOn: '',
      toSet: 'a',
      valueToSetTo: 12
    };
  }

  render() {
    return React.createElement(React.Fragment, null, React.createElement("div", null, "Set", ' ', React.createElement("input", {
      style: {
        width: '9em'
      },
      onChange: this.handleSetToChange,
      value: this.state.toSet
    }), ' ', "=", ' ', React.createElement("input", {
      style: {
        width: '9em'
      },
      onChange: this.handleValueChange,
      value: this.state.valueToSetTo
    }), React.createElement("button", {
      style: {
        fontSize: '13px',
        lineHeight: '13px',
        padding: '2px',
        color: 'royalblue'
      },
      onClick: () => this.handleSetTo()
    }, React.createElement("span", null, "\u2714"), "\uFE0F Set")), React.createElement("div", {
      className: "device"
    }, React.createElement("div", {
      style: {
        flexGrow: 2
      }
    }, React.createElement(Registers, {
      registers: this.registers
    }), React.createElement("br", null), React.createElement(BreakOn, {
      setDeviceBreakOn: this.setDeviceBreakOn
    })), React.createElement(Program, {
      program: this.program,
      instruction: this.instruction
    }), this.instruction > this.program.length - 1 ? null : React.createElement(Controls, {
      step: this.step,
      runUntilBreak: this.runUntilBreak
    })), React.createElement("button", {
      style: {
        fontSize: '1em'
      },
      onClick: this.reset
    }, "Reset"));
  }

} // END - Device.js


const initial_data = `cpy a b
dec b
cpy a d
cpy 0 a
cpy b c
inc a
dec c
jnz c -2
dec d
jnz d -5
dec b
cpy b c
cpy c d
dec d
inc c
jnz d -2
tgl c
cpy -16 c
jnz 1 c
cpy 99 c
jnz 77 d
inc a
inc d
jnz d -2
inc c
jnz c -5`;

class App extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "parseProgramAndRun", () => {
      let data_str = String(this.data_ref.current.value).trim();

      if (!data_str) {
        this.setState({
          dataError: "Empty program passed in."
        });
        return;
      }

      let data_arr = data_str.split("\n");
      const data = []; // Run using for loop instead of `map` so I can catch errors

      try {
        for (let i = 0; i < data_arr.length; i++) {
          data.push(parseLine(data_arr[i]));
        }
      } catch (e) {
        this.setState({
          dataError: e.toString()
        });
        return;
      } // If we are here, we have a valid data


      this.setState({
        data,
        run: true
      });
    });

    this.data_ref = React.createRef();
    this.state = {
      data: null,
      run: false,
      dataError: ""
    };
  }

  componentDidMount() {
    this.data_ref.current.value = initial_data;
  }

  render() {
    if (!this.state.run) {
      return React.createElement("div", null, React.createElement("p", null, "Enter the program input, separated by newlines:"), React.createElement("textarea", {
        rows: "16",
        cols: "46",
        ref: this.data_ref,
        onClick: () => this.setState({
          dataError: null
        })
      }), React.createElement("div", null, React.createElement("button", {
        onClick: () => this.parseProgramAndRun()
      }, "Run Program"), this.state.dataError ? React.createElement("p", {
        style: {
          color: "red"
        }
      }, this.state.dataError) : null));
    }

    return React.createElement(Device, {
      program: this.state.data
    });
  }

}

const rootElement = document.getElementById('root');
ReactDOM.render(React.createElement(App, null), rootElement);